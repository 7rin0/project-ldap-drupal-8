<?php
/** @file
 *
 *  Provisions Drupal roles to LDAP groups.
 *
 *
 * The current workflow is to take action when users are added, edited,
 * or deleted and ignore role actions. We don't care if a role is added
 * until a user is added to it. In fact, many LDAP servers will refuse
 * to create a group without a user.
 *
 */
define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_CREATED', 1);
define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_UPDATED', 2);
define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_DELETED', 3);
define('LDAP_GROUPS_PROV_NO_CREATE', 1);
define('LDAP_GROUPS_PROV_NO_REMOVE', 2);
define('LDAP_GROUPS_PROV_DELETE_EMPTY_GROUPS', 3);

/**
 * Implements hook_menu().
 */
function ldap_groups_menu() {
  $items = array();

  $items['admin/config/people/ldap/groups'] = array(
    'title' => 'Groups',
    'description' => 'Settings related to LDAP Groups.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_groups_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 7,
    'file' => 'ldap_groups.admin.inc',
  );

  return $items;
}

/**
 *
 * return ldap group conf object
 *
 * @param enum $type 'default', 'admin',
 * @param boolean $reset do not use cached or static result
 * @return LdapGroupsConf or LdapGroupsConfAdmin object
 */
function ldap_groups_conf($type = 'default', $reset = FALSE) {

  static $ldapGroupsConf;
  static $ldapGroupsConfAdmin;

  if ($type == 'admin' && (!$ldapGroupsConfAdmin || $reset)) {
    ldap_server_module_load_include('php', 'ldap_groups', 'LdapGroupsConfAdmin.class');
    $ldapGroupsConfAdmin = new LdapGroupsConfAdmin();
  }
  elseif (!$ldapGroupsConf || $reset) {
    ldap_server_module_load_include('php', 'ldap_groups', 'LdapGroupsConf.class');
    $ldapGroupsConf = new LdapGroupsConf();
  }
  return ($type == 'admin') ? $ldapGroupsConfAdmin : $ldapGroupsConf;

}

function ldap_groups_conf_cache_clear() {
  $discard = ldap_groups_conf('admin', TRUE);
  $discard = ldap_groups_conf(NULL, TRUE);
}

/**
 * We may or may not need to use the Drupal user hooks directly.
 * We won't have any information about what is going on with the
 * LDAP user if we do.
 */
function ldap_groups_user_presave(&$edit, $account, $category) {
}
function ldap_groups_user_insert(&$edit, $account, $category) {
}
function ldap_groups_user_update(&$edit, $account, $category) {
}
function ldap_groups_user_delete($account) {
}
/**
 * Implements hook_form_FORM_ID_alter().
 */
function ldap_groups_form_user_register_form_alter(&$form, &$form_state) {
}
function ldap_groups_form_user_profile_form_alter(&$form, &$form_state) {
}

  // AFTER user is created:

  // Loop through Drupal user roles and see if they exist in LDAP.
  // Swap actual role with token replacement?
  // Provide a dn and get a group, if any.
  // We need a way to know what attribute to look for (a variable).

  // If group does not exist, create it, then add user.
  // If group does exist, see if user is in it, if not add them.
  // See if they have lost a role and need to be removed.

  // What happens to Drupal role when LDAP role goes away?
  // If someone has admin role in Drupal but not LDAP they should not lose it?? (when provisioning from LDAP)

  // Configuration option, should LDAP override or Drupal? Which is authoritative? Does that need to be at attribute level?
  // Need something like:

  // Revoke drupal roles previously granted by LDAP Authorization but no longer valid.
  // Re grant drupal roles previously granted by LDAP Authorization but removed manually.
  // Create drupal roles if they do not exist.

  // DELETE USER
  // Operate before user is deleted so we know their roles.


/**
 * See if a Drupal role and a LDAP group are the same.
 * Test is wrapped in a function to centralize the comparison
 * logic in a single place.
 */
function ldap_groups_compare($role, $group) {
  if (ldap_groups_role_to_group($role) == $group) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Function to return the name of the group, based on the
 * name of the role. They might be the same, or might need
 * token substitutions.
 */
function ldap_groups_role_to_group($role) {
  // Do whatever needs to be done to alter the name.
  return $role;
}

/**
 * Function to create the dn for a user role.
 */
function ldap_groups_role_to_dn($role, $ldap_server) {
  $attribute_name = variable_get('ldap_groups_attribute_name');
  $base_dn = variable_get('ldap_groups_base_dn');
  $attribute_name = variable_get('ldap_groups_attribute_name', 'cn');
  $dn = $attribute_name . '='. $role .',' . $basedn;
  return $dn;
}


/**
 * Implements ldap_entry_pre_provision_alter().
 *
 * Used to take action before the ldap entry is written.
 *
 * If we're about to remove the last user from a group, we need
 * to prepare for that action before actually editing the user.
 */
function ldap_groups_ldap_entry_pre_provision_alter($ldap_entries, $ldap_server, $context) {

 // What do we need to do beforehand? Not sure yet.
}

/**
 * Implements ldap_entry_post_provision().
 *
 * Used to take action after the ldap entry is written.
 */
function ldap_groups_ldap_entry_post_provision($ldap_entries, $user_provisioning_ldap_server, $context) {

  // ATM we only care about user actions.
  $type = $context['corresponding_drupal_data_type'];
  if ($type != 'user') {
    return;
  }

  $op = $context['action']; //'add', 'update', 'delete'

  $ldap_groups_conf = ldap_groups_conf();
  $attribute_name = $ldap_groups_conf->ldapProvisionGroupsRoleAttribute;
  $base_dn = $ldap_groups_conf->ldapProvisionGroupsBaseDn;
  $object_class = $ldap_groups_conf->groupObjectClass;
  $sid = $ldap_groups_conf->ldapProvisionSid;
  $group_provisioning_ldap_server = $ldap_groups_conf->ldapProvisionServer;

  foreach ($ldap_entries as $lcase_dn => $ldap_entry) {
    $user = $context['corresponding_drupal_data'][$lcase_dn];
    $roles = $user->roles();

    // The only way we can be sure which groups a user belongs to is
    // to query the LDAP server. Even checking the previous roles in
    // Drupal won't tell us what LDAP groups they're in.

    $add = array();
    $remove = array();

    // Find the groups this user belongs to, so we can compare it
    // to the roles they have in Drupal. They might have a group in LDAP
    // that they need to be removed from.

    $ldap_groups = $ldap_groups_conf->ldap_authorization->ldapGetGroups($user);

    foreach ($roles as $rid => $role) {

      // Ignore the authenticated and anonymous roles.
      if ($rid == DRUPAL_AUTHENTICATED_RID || $rid == DRUPAL_ANONYMOUS_RID) {
        continue;
      }
      foreach ($ldap_groups as $group) {
        // There was a group on LDAP that they don't currently have a
        // role for. We need to remove them from that group.
        if (!ldap_groups_compare($role, $group)) {
          $remove[] = $group;
        }
        // They have a role for a group they are not in yet.
        // We need to add them to the group.
        else {
          $add[] = $role;
        }
      }
    }

    // Now we have an array of groups we need to add and remove this
    // user from.

    foreach ($remove as $role) {
      ldap_groups_remove_user($role, $ldap_user, $group_provisioning_ldap_server);
    }

    foreach ($add as $role) {
      ldap_groups_add_user($role, $ldap_user, $group_provisioning_ldap_server);
    }
  }
}

/**
 * Query for the existance of a LDAP group.
 *
 * We might do one query by joining all roles to search for.
 * But the LDAP directory may limit results and not return all of them,
 * so it is better to do one query at a time.
 * LDAP is optimized for reads, so this should be OK.
 *
 * In config identify the ldap attribute for the role (i.e. cn).
 * Do a search for '(' . $attribute_name .'='. $role .')';
 */
function ldap_groups_get_group($role, $ldap_server = NULL) {
  $attribute_name = variable_get('ldap_groups_attribute_name');
  $base_dn = variable_get('ldap_groups_base_dn');

  // Make sure $ldap_server is a valid LdapServer object.
  if ($ldap_server === NULL) {
    $sid = variable_get('ldap_groups_sid');
    $ldap_server = ldap_servers_get_servers($sid, NULL, TRUE);
  }

  // Search for the role.
  $filter = '(' . $attribute_name . '=' . $role . ')';
  $entry = $ldap_server->search($base_dn, $filter);

  // Error handler.
  if ($entry === FALSE || $entry['count'] == 0) {
    return FALSE;
  }

  // Return the first entry found. If more than one are found, other strange
  // things will be happening with the directory, and the directory admin will
  // need to fix it.
  return $entry[0];
}

/**
 * See if a user is a member of a LDAP group.
 */
function ldap_groups_check_membership($role, $ldap_user, $group_provisioning_ldap_server) {
  $dn = ldap_groups_get_dn($role);

}

/**
 * Add a new LDAP group.
 */
function ldap_groups_add_group($role, $group_provisioning_ldap_server) {
  $dn = ldap_groups_get_dn($role);

}

/**
 * Remove a LDAP group.
 */
function ldap_groups_remove_group($role, $group_provisioning_ldap_server) {
  $dn = ldap_groups_get_dn($role);
}

/**
 * Add a LDAP user to a LDAP group.
 */
function ldap_groups_add_user($role, $ldap_user, $group_provisioning_ldap_server) {
  $dn = ldap_groups_get_dn($role);

  // If we're about to add a user to a group, we need to verify
  // that the group exists first.
  if (!ldap_groups_get_group($role, $group_provisioning_ldap_server)) {
    ldap_groups_add_group($role, $group_provisioning_ldap_server);
  }
  // Now add memberâ€¦.

}

/**
 * A function to remove a LDAP user from a LDAP group.
 */
function ldap_groups_remove_user($role, $ldap_user, $group_provisioning_ldap_server) {
  $dn = ldap_groups_get_dn($role);

  // See if this is the last member of a group before removing them.
  if ($last_user) {
    ldap_groups_remove_group($role, $group_provisioning_ldap_server);
  }
  // Now remove member...

}

