<?php
/** @file
 *
 *  Provisions Drupal roles to LDAP groups.
 *
 */

define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_CREATED', 1);
define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_UPDATED', 2);
define('LDAP_GROUPS_PROV_ON_LDAP_ENTRY_DELETED', 3);
define('LDAP_GROUPS_PROV_NO_CREATE', 1);
define('LDAP_GROUPS_PROV_NO_REMOVE', 2);
define('LDAP_GROUPS_PROV_DELETE_EMPTY_GROUPS', 3);
/**
 * Implements hook_menu().
 */
function ldap_groups_menu() {
  $items = array();

  $items['admin/config/people/ldap/groups'] = array(
    'title' => 'Groups',
    'description' => 'Settings related to LDAP Groups.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_groups_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 7,
    'file' => 'ldap_groups.admin.inc',
  );

  return $items;
}


/**
 * We may or may not need to use the Drupal user hooks directly.
 * We won't have any information about what is going on with the
 * LDAP user if we do.
 */
function ldap_groups_user_presave(&$edit, $account, $category) {
}
function ldap_groups_user_insert(&$edit, $account, $category) {
}
function ldap_groups_user_update(&$edit, $account, $category) {
}
function ldap_groups_user_delete($account) {
}

/**
 *
 * return ldap group conf object
 *
 * @param enum $type 'default', 'admin',
 * @param boolean $reset do not use cached or static result
 * @return LdapGroupsConf or LdapGroupsConfAdmin object
 */
   
function ldap_groups_conf($type = 'default', $reset = FALSE) {
  
  static $ldapGroupsConf;
  static $ldapGroupsConfAdmin;

  if ($type == 'admin' && (!$ldapGroupsConfAdmin || $reset)) {
    ldap_server_module_load_include('php', 'ldap_groups', 'LdapGroupsConfAdmin.class');
    $ldapGroupsConfAdmin = new LdapGroupsConfAdmin();
  }
  elseif (!$ldapGroupsConf || $reset) {
    ldap_server_module_load_include('php', 'ldap_groups', 'LdapGroupsConf.class');
    $ldapGroupsConf = new LdapGroupsConf();
  }
  return ($type == 'admin') ? $ldapGroupsConfAdmin : $ldapGroupsConf;
  
}

function _ldap_groups_conf_if_not($object) {
  if ($object) {
    return $object;
  }
  else {
    return ldap_groups_conf();
  }
}

function ldap_groups_conf_cache_clear() {
  $discard = ldap_groups_conf('admin', TRUE);
  $discard = ldap_groups_conf(NULL, TRUE);
}

/**
 * Implements a hook to be added to ldap_user or ldap_server.
 * Adding it to the server will make it usable in other ways.
 * We need add context to the hook so we know what operation is
 * being performed and we need both the LDAP entry and Drupal object.
 * We need two hooks, one before and one after the LDAP user is created
 * or modified.
 */
function ldap_groups_ldap_entry_post_provision($ldap_entries, $user_provisioning_ldap_server, $context) {
  $type = $context['corresponding_drupal_data_type'];
  if ($type != 'user') {
    return;
  }

  $op = $context['action']; //'add', 'update', 'delete'
  
  $ldap_groups_conf = ldap_groups_conf();
  $attribute_name = $ldap_groups_conf->ldapProvisionGroupsRoleAttribute;
  $base_dn = $ldap_groups_conf->ldapProvisionGroupsBaseDn;
  $sid = $ldap_groups_conf->ldapProvisionSid;
  $ldap_server = $ldap_groups_conf->ldapProvisionServer;
  $object_class = $ldap_server->groupObjectClass;  

  foreach ($ldap_entries as $lcase_dn => $ldap_entry) {
    $user = $context['corresponding_drupal_data'][$lcase_dn];
   // $users_groups = $ldap_server->
  // AFTER user is created:

  // Loop through Drupal user roles and see if they exist in LDAP.
  // Swap actual role with token replacement?
  // Provide a dn and get a group, if any.
  // We need a way to know what attribute to look for (a variable).

  // If group does not exist, create it, then add user.
  // If group does exist, see if user is in it, if not add them.
  // See if they have lost a role and need to be removed.

  // What happens to Drupal role when LDAP role goes away?
  // If someone has admin role in Drupal but not LDAP they should not lose it?? (when provisioning from LDAP)
  
  // Configuration option, should LDAP override or Drupal? Which is authoritative? Does that need to be at attribute level?
  // Need something like:

  // Revoke drupal roles previously granted by LDAP Authorization but no longer valid.
  // Re grant drupal roles previously granted by LDAP Authorization but removed manually.
  // Create drupal roles if they do not exist. 

  // DELETE USER
  // Operate before user is deleted so we know their roles.

  }
  
}

/**
 * Query for the existance of a LDAP group.
 *
 * We might do one query by joining all roles to search for.
 * But the LDAP directory may limit results and not return all of them,
 * so it is better to do one query at a time.
 * LDAP is optimized for reads, so this should be OK.
 *
 * In config identify the ldap attribute for the role (i.e. cn).
 * Do a search for '(' . $attribute_name .'='. $role .')';
 *
 */
function ldap_groups_get_group_dn_from_role($role, $ldap_groups_conf = NULL) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  return $ldap_groups_conf->groupDnFromRole($role);
}

/**
 * See if a user is a member of a LDAP group.
 *
 * @param string $role as drupal role in string form
 * @param array $ldap_user as ldap entry array
 * @param LdapGroupsConf $ldap_groups_conf.  ldap groups configuration object
 * @param enum $nested = NULL (default to server configuration), TRUE, or FALSE indicating to test for nested groups
 */
function ldap_groups_check_membership($role, $ldap_user_entry, $ldap_groups_conf = NULL, $nested = NULL) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  $group_dn = $ldap_groups_conf->groupDnFromRole($role);
  return ($group_dn) ? $ldap_groups_conf->ldapProvisionServer->groupIsMember($group_dn, $ldap_user_entry['dn'], $nested) : FALSE;
}

/**
 * Add a new LDAP group.
 * 
 * @param string $role as drupal role in string form
 * @param LdapGroupsConf $ldap_groups_conf.  ldap groups configuration object
 */
function ldap_groups_add_group($role, $ldap_groups_conf = NULL) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  $group_dn = $ldap_groups_conf->groupDnFromRole($role);
  $result = $ldap_groups_conf->ldapProvisionServer->groupAddGroup($group_dn);
}

/**
 * Remove a LDAP group.
 * 
 * @param string $role as drupal role in string form
 * @param LdapGroupsConf $ldap_groups_conf.  ldap groups configuration object
 * @param boolean $only_if_group_empty indicating if group should not be removed if not empty
 */
function ldap_groups_remove_group($role, $ldap_groups_conf = NULL, $only_if_group_empty = TRUE) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  $group_dn = $ldap_groups_conf->groupGetGroupDnFromRole($role);
  $result = $ldap_groups_conf->ldapProvisionServer->groupRemoveGroup($group_dn, $only_if_group_empty);
}

/**
 * Add a LDAP user to a LDAP group.
 * 
 * @param string $role as drupal role in string form
 * @param array $ldap_user_entry in ldap array format
 * @param LdapGroupsConf $ldap_groups_conf.  ldap groups configuration object
 */
function ldap_groups_add_user($role, $ldap_user_entry, $ldap_groups_conf = NULL) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  $group_dn = $ldap_groups_conf->groupGetGroupDnFromRole($role);
  $result = $ldap_groups_conf->ldapProvisionServer->groupAddMember($group_dn, $ldap_user_entry['dn']);

}

/**
 * A function to remove a LDAP user from a LDAP group.
 */
function ldap_groups_remove_user($role, $ldap_groups_conf, $ldap_user, $ldap_groups_conf = NULL) {
  $ldap_groups_conf = _ldap_groups_conf_if_not($ldap_groups_conf);
  $group_dn = $ldap_groups_conf->groupGetGroupDnFromRole($role);
  $result = $ldap_groups_conf->ldapProvisionServer->groupRemoveMember($group_dn, $ldap_user['dn']);
}

