<?php

/**
 * @file
 * Module for the LDAP User Entity
 *
 */

define('LDAP_USER_DRUPAL_HELP_URL', 'http://drupal.org/node/997082');

// configurable states where synch or provision to drupal user could occur
define('LDAP_USER_DRUPAL_USER_CREATE_ON_LOGON', 1);
define('LDAP_USER_DRUPAL_USER_CREATE_ON_MANUAL_ACCT_CREATE', 2);
define('LDAP_USER_DRUPAL_USER_CREATE_ON_ALL_USER_CREATION', 3);
define('LDAP_USER_DRUPAL_USER_UPDATE_ON_USER_AUTHENTICATE', 6);
define('LDAP_USER_DRUPAL_USER_UPDATE_ON_USER_UPDATE', 7);
define('LDAP_USER_DRUPAL_USER_CANCEL_ON_LDAP_ENTRY_MISSING', 4);
define('LDAP_USER_DRUPAL_USER_DELETE_ON_LDAP_ENTRY_MISSING', 5);

// configurable states where synch or provision to ldap entry could occur
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_STATUS_IS_1', 2);
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_UPDATE', 3);
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_AUTHENTICATE', 4);
define('LDAP_USER_LDAP_ENTRY_UPDATE_ON_USER_UPDATE', 5);
define('LDAP_USER_LDAP_ENTRY_UPDATE_ON_USER_AUTHENTICATE', 6);
define('LDAP_USER_LDAP_ENTRY_DELETE_ON_USER_DELETE', 7);

// results of ldap entry provisioning
define('LDAP_USER_PROVISION_LDAP_ENTRY_EXISTS', 1);
define('LDAP_USER_PROVISION_LDAP_ENTRY_CREATE_FAILED', 2);
define('LDAP_USER_PROVISION_LDAP_ENTRY_SYNCH_FAILED', 3);

define('LDAP_USER_CONFLICT_LOG', 1);
define('LDAP_USER_CONFLICT_RESOLVE', 2);
define('LDAP_USER_CONFLICT_RESOLVE_DEFAULT', 2);

define('LDAP_USER_MANUAL_ACCT_CONFLICT_REJECT', 1);
define('LDAP_USER_MANUAL_ACCT_CONFLICT_LDAP_ASSOCIATE', 2);
define('LDAP_USER_MANUAL_ACCT_CONFLICT_SHOW_OPTION_ON_FORM', 3);
define('LDAP_USER_MANUAL_ACCT_CONFLICT_NO_LDAP_ASSOCIATE', 4);

define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR', 4);
define('LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP', 1);
define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR_DEFAULT', 4);

define('LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY', 2);
define('LDAP_USER_SYNCH_DIRECTION_NONE', 3);
define('LDAP_USER_SYNCH_DIRECTION_ALL', 4);

define('LDAP_USER_PROVISION_RESULT_NO_ERROR', 0);
define('LDAP_USER_PROVISION_RESULT_NO_PWD', 1);
define('LDAP_USER_PROVISION_RESULT_BAD_PARAMS', 2);

// SYNCH CONTEXTS are actions which may cause provisioning or synching of drupal accounts or ldap entries
define('LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER', 2);
define('LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER', 3);
define('LDAP_USER_SYNCH_CONTEXT_CRON', 4);
define('LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER', 5);
define('LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER', 6);
define('LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER', 7);
define('LDAP_USER_SYNCH_CONTEXT_LDAP_ASSOCIATE', 9); // existing drupal user is being ldap associated.  only synch ldap associatiation fields
define('LDAP_USER_SYNCH_CONTEXT_MANUAL_LDAP_CREATE', 10); // existing drupal user is being ldap associated.  only synch ldap associatiation fields
define('LDAP_USER_SYNCH_CONTEXT_ALL', 7);
define('LDAP_USER_SYNCH_CONTEXT_NONE', 8);

define('LDAP_USER_NO_SERVER_SID', '{LDAP_USER.NO_SERVER_ID}'); // need to avoid conflicting with server ids

define('LDAP_USER_TEST_FORM_PATH', 'admin/config/people/ldap/user/test');

define('LDAP_USER_WS_USER_PATH', 'ldap/user/ws');

/**
 * Implements hook_menu().
 */
function ldap_user_menu() {
  $items = array();

  $items['admin/config/people/ldap/user'] = array(
    'title' => '3. User',
    'description' => 'Settings related to user provisioning and data synching between ldap and drupal users.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'ldap_user.admin.inc',
  );

  $items[LDAP_USER_TEST_FORM_PATH] = array(
    'title' => 'Test LDAP User Functionality for a given user.',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_test_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ldap_user.test_form.inc',
    'type' => MENU_LOCAL_ACTION,
  );

  $ws_arg_start = count(explode('/', LDAP_USER_WS_USER_PATH));
  $items[LDAP_USER_WS_USER_PATH] = array(
    'title' => 'Webservice Path',
    'page callback' => 'ldap_user_ws',
    'page arguments' => array($ws_arg_start, $ws_arg_start + 1, $ws_arg_start + 2),
    'access arguments' => array('view content'),
    'file' => 'ldap_user.ws.inc',
  );

  return $items;
}

/**
 * Implements hook_init().
 */
function ldap_user_init() {
  ldap_user_ldap_provision_semaphore('set_page_load', NULL, NULL);
}

/**
 * Implements hook_theme().
 */
function ldap_user_theme() {
  return array('ldap_user_conf_form' => array(
    'render element' => 'form',
    'file' => 'ldap_user.theme.inc'
    ),
  );
}

/**
 * Implements hook_cron().
 */
function ldap_user_cron() {
  $ldap_user_conf = ldap_user_conf();
  if ($ldap_user_conf->orphanedDrupalAcctBehavior != 'ldap_user_orphan_do_not_check') {
    module_load_include('inc', 'ldap_user', 'ldap_user.cron');
    _ldap_user_orphans($ldap_user_conf);
  }
}

function ldap_user_conf_cache_clear() {
  $discard = ldap_user_conf('admin', TRUE);
  $discard = ldap_user_conf(NULL, TRUE);
}

/**
 * get ldapUserConf or ldapUserConfAdmin object
 *
 * @param enum $type is 'admin' for ldapUserConfAdmin object or NULL for ldapUserConf object
 * @param boolean $resect clear static cache of object.
 *
 * @return object ldapUserConf or ldapUserConfAdmin object
 */
function ldap_user_conf($type = NULL, $reset = FALSE) {
  static $ldap_user_conf;
  static $ldap_user_conf_admin;

  if ($type == 'admin' && ($reset || !is_object($ldap_user_conf_admin))) {
    ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConfAdmin.class');
    $ldap_user_conf_admin = new LdapUserConfAdmin();
  }
  elseif ($type != 'admin' && ($reset || !is_object($ldap_user_conf))) {
    ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConf.class');
    $ldap_user_conf = new LdapUserConf();
  }

  return ($type == 'admin') ? $ldap_user_conf_admin : $ldap_user_conf;
}


/**
 * implements hook_ldap_attributes_needed_alter().
 */
function ldap_user_ldap_attributes_needed_alter(&$attributes, $params) {
  // debug("ldap_user_ldap_attributes_needed_alter synch_context=$synch_context");
  //@todo need to load all ldap_user attributes used in synch mapping and add to list based on synch context.

  if (isset($params['sid']) && $params['sid'] && $params['sid'] != LDAP_USER_NO_SERVER_SID) { // puid attributes are server specific
    if (is_scalar($params['sid'])) {
      $ldap_server = ldap_servers_get_servers($params['sid'], 'enabled', TRUE);
    }
    else {
      $ldap_server = $params['sid'];
    }

    $ldap_user_conf = ldap_user_conf();
    if (!isset($attributes['dn'])) {
      $attributes['dn'] = array(); 
    }
    $attributes['dn'] = ldap_servers_set_attribute_map($attributes['dn'], 'ldap_dn', 'ldap_dn'); // force this data type
    switch ($params['synch_context']) { // Add the attributes required by the user configuration when provisioning drupal users
      case LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_LDAP_ASSOCIATE:
      case LDAP_USER_SYNCH_CONTEXT_MANUAL_LDAP_CREATE:
        $attributes[$ldap_server->user_attr] = ldap_servers_set_attribute_map(@$attributes[$ldap_server->user_attr]); // array($ldap_server->user_attr, 0, NULL); 
        $attributes[$ldap_server->mail_attr] = ldap_servers_set_attribute_map(@$attributes[$ldap_server->mail_attr]);
        $attributes[$ldap_server->unique_persistent_attr] = ldap_servers_set_attribute_map(@$attributes[$ldap_server->unique_persistent_attr]);
        if ($ldap_server->mail_template) {
          ldap_servers_token_extract_attributes($attributes,  $ldap_server->mail_template);  
        }
      break;  
        
      case LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_CRON:
      case LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER:
      case LDAP_TEST_QUERY_CONTEXT:
    

      break;

    }
    
    $attributes_required_by_user_module_mappings = $ldap_user_conf->getRequiredAttributes($params['direction'], $params['synch_context']);
    $attributes = array_merge($attributes_required_by_user_module_mappings, $attributes);

  }
}

/**
 * implements hook_ldap_user_attrs_list_alter()
 *
 */
function ldap_user_ldap_user_attrs_list_alter(&$available_user_attrs, &$params) {
  
  $sid = (isset($params['ldap_server']) && is_object($params['ldap_server'])) ? $params['ldap_server']->sid : LDAP_USER_NO_SERVER_SID;

  $ldap_user_conf = $params['ldap_user_conf'];
  $direction = isset($params['direction']) ? $params['direction'] : LDAP_USER_SYNCH_DIRECTION_NONE; 
  $all_contexts = ldap_user_synch_contexts();

  if ($direction == LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY) {
    $available_user_attrs['[property.name]'] =  array(
      'name' => 'Property: Username',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => $all_contexts,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
      );
    
    $available_user_attrs['[property.mail]'] =  array(
      'name' => 'Property: Email',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => $all_contexts,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
    );
    
  }
    
  // 1. Drupal user properties
  // 1.a make sure empty array are present so array + function works
  foreach (array('property.status','property.timezone','property.signature') as $i => $property_id) {
    $property_token = '[' . $property_id  .']';
    if (!isset($available_user_attrs[$property_token]) || !is_array($available_user_attrs[$property_token])) {
      $available_user_attrs[$property_token] = array();
    }
  }
  //@todo make these merges so they don't override saved values such as 'enabled'
  $available_user_attrs['[property.status]'] = $available_user_attrs['[property.status]'] + array(
    'name' => 'Property: Acount Status',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'user_tokens' => '1=enabled, 0=blocked.',
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['[property.timezone]'] = $available_user_attrs['[property.timezone]'] + array(
    'name' => 'Property: User Timezone',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['[property.signature]'] = $available_user_attrs['[property.signature]'] + array(
    'name' => 'Property: User Signature',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  // 2. Drupal user fields
  $user_fields = field_info_instances('user', 'user');
  foreach ($user_fields as $field_name => $field_instance) {
    $field_id = "[field.$field_name]";
    if (!isset($available_user_attrs[$field_id]) || !is_array($available_user_attrs[$field_id])) {
      $available_user_attrs[$field_id] = array();
    }
   // dpm($field_id);
   // dpm($available_user_attrs[$field_id]);
    $available_user_attrs[$field_id] = $available_user_attrs[$field_id] + array(
      'name' => t('Field: '). $field_instance['label'],
      'configurable_to_drupal' => 1,
      'configurable_to_ldap' => 1,
      'enabled' => FALSE,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
    );
  }


  if (!$ldap_user_conf->provisionsDrupalAccountsFromLdap) {
    $available_user_attrs['[property.mail]']['config_module'] = 'ldap_user';
    $available_user_attrs['[property.name]']['config_module'] = 'ldap_user';
  }
  
  if ($direction == LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY) {
    $available_user_attrs['[password.random]'] =  array(
      'name' => 'Pwd: Random',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => $all_contexts,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
    );
    
    // only works in contexts where user password is available
    $available_user_attrs['[password.user]'] =  array(
      'name' => 'Pwd: User',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => array(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, LDAP_USER_SYNCH_CONTEXT_LDAP_ASSOCIATE, LDAP_USER_SYNCH_CONTEXT_MANUAL_LDAP_CREATE ),
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
    );
  
    // use user password when available fall back to random pwd
    $available_user_attrs['[password.user-random]'] =  array(
      'name' => 'Pwd: User or Random',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => $all_contexts,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
    );
    
    // use user password when available fall back to not supplying password
    $available_user_attrs['[password.user-none]'] =  array(
      'name' => 'Pwd: User or None',
      'source' => '',
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY,
      'enabled' => TRUE,
      'contexts' => $all_contexts,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
      'configurable_to_ldap' => TRUE,
    );
  }
    
  //this is where need to be added to arrays
  if (is_array($ldap_user_conf->ldapUserSynchMappings) && isset($ldap_user_conf->ldapUserSynchMappings[$direction][$sid])) {

    foreach ($ldap_user_conf->ldapUserSynchMappings[$direction][$sid] as $target_token => $mapping) {
      if ($direction == LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER && isset($mapping['user_attr'])) {
        $key = $mapping['user_attr'];
      }
      elseif ($direction == LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY && isset($mapping['ldap_attr'])) {
        $key = $mapping['ldap_attr'];
      }
      else {
        continue;
      }


      foreach (array('sid','ldap_attr','user_attr','convert','direction','enabled','contexts') as $k) {
        if (isset($mapping[$k])) {
          $available_user_attrs[$key][$k] = $mapping[$k];
        }
        else {
          $available_user_attrs[$key][$k] = NULL;
        }
        $available_user_attrs[$key]['config_module'] = 'ldap_user';
        $available_user_attrs[$key]['synch_module'] = 'ldap_user';
      }
      if ($mapping['user_attr'] == 'user_tokens') {
        $available_user_attrs['user_attr'] = $mapping['user_tokens'];
      }

    }
  }

   // 3. profile2 fields
  // 4. $user->data array.   will need to be added manually.  perhaps better not to implement this at all?


}
/**
 * Implements hook_help().
 */

function ldap_user_help($path, $arg) {

  $ldap_user_help = t('LDAP user configuration determines how and when
    Drupal accounts are created based on LDAP data and which user fields
    are derived and synched to and from LDAP. See !helplink.',
    array(
      '!helplink' => l(LDAP_USER_DRUPAL_HELP_URL, LDAP_USER_DRUPAL_HELP_URL),
    ));

  switch ($path) {
    case 'admin/config/people/ldap/user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;

    case 'admin/help#ldap_user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;
  }
}

function ldap_user_form_alter(&$form, $form_state, $form_id) {
 // dpm($form_id); dpm($form); dpm($form_state);
}

/**
 * Implements hook_form_FORM_ID_alter(). for user_register_form
 */
function ldap_user_form_user_profile_form_alter(&$form, $form_state) {

  array_unshift($form['#submit'], 'ldap_user_form_user_profile_form_submit1');
}

function ldap_user_form_user_profile_form_submit1(&$form, &$form_state) {
  if (isset($form_state['values']['pass']) && $form_state['values']['pass']) {
    ldap_user_ldap_provision_semaphore('set_user_pass', NULL, $form_state['values']['pass']);
  }
}


/**
 * Implements hook_form_FORM_ID_alter(). for user_register_form
 */
function ldap_user_form_user_register_form_alter(&$form, $form_state) {
  //dpm('ldap_user_form_user_register_form_alter'); dpm($form); dpm($form_state);
  if (!user_access('administer users')) {
    return;
  }
  $ldap_user_conf = ldap_user_conf();
  
  $ldap_fieldset = array();
  if ($ldap_user_conf->manualAccountConflict == LDAP_USER_MANUAL_ACCT_CONFLICT_SHOW_OPTION_ON_FORM) {
    $options = array(
      LDAP_USER_MANUAL_ACCT_CONFLICT_LDAP_ASSOCIATE => t('Make this an LDAP Associated account.  If a related LDAP account can not be found, a validation error will appear and the account will not be created.'),
      LDAP_USER_MANUAL_ACCT_CONFLICT_NO_LDAP_ASSOCIATE => t('Do not make this an LDAP Associated account.'),
    );
    $ldap_fieldset['ldap_user_association'] = array(
      '#type' => 'radios',
      '#options' => $options,
      '#required' => FALSE,
      '#title' => t('LDAP Entry Association.'),
    );  
  }
 
  if ($ldap_user_conf->ldapEntryProvisionServer != LDAP_USER_NO_SERVER_SID) {
    $ldap_fieldset['ldap_user_create_ldap_acct'] = array(
      '#type' => 'checkbox',
      '#title' => t('Create corresponding LDAP entry.'),
    );
        
    if (in_array(LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_STATUS_IS_1, $ldap_user_conf->ldapEntryProvisionEvents)) {
      // account will be created if status = 1
      $ldap_fieldset['ldap_user_create_ldap_acct']['#description'] = t('(LDAP User configuration is already set to automatically create LDAP entry when its status becomes "active")
        Checking this will create the LDAP account even if its status is set to "Blocked"');
    }
  }
  
  if (count($ldap_fieldset) > 0) {
    $form['ldap_user_fields'] = $ldap_fieldset;
    $form['ldap_user_fields']['#type'] = 'fieldset';
    $form['ldap_user_fields']['#title'] =  t('LDAP Options');
    $form['ldap_user_fields']['#collapsible'] =  TRUE;
    $form['ldap_user_fields']['#collapsed'] =  FALSE;
  }
  
  $form['#validate'][] = 'ldap_user_form_register_form_validate';
  $form['#submit'][] = 'ldap_user_form_register_form_submit';

  array_unshift($form['#submit'], 'ldap_user_form_register_form_submit1');
  $form['#submit'][] = 'ldap_user_form_register_form_submit2';
    
}


function ldap_user_form_register_form_validate($form, &$form_state) {
  
  $values = $form_state['values'];
  $user_ldap_entry = NULL;
  $drupal_username = $form_state['values']['name'];
  //dpm('ldap_user_form_register_form_validate'); dpm($form_state['values']);
 
  // if corresponding ldap account doesn't exist and provision not selected and make ldap associated is selected, throw error
  if (!@$values['ldap_user_create_ldap_acct'] && @$values['ldap_user_association'] == LDAP_USER_MANUAL_ACCT_CONFLICT_LDAP_ASSOCIATE) {
    $ldap_user_conf = ldap_user_conf();
    $ldap_user = ldap_servers_get_user_ldap_data($drupal_username, $ldap_user_conf->ldapEntryProvisionServer, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER); 
    if (!$ldap_user) {
     // dpm($ldap_user);
      form_set_error('ldap_user_association', t('User %name does not have a corresponding LDAP Entry (dn).
        Under LDAP options, you may not select "Make this an LDAP Associated Account"', array('%name' => $drupal_username)));
    }
  }
  
  // if trying to provision and ldap account and one already exists, throw error.
  if (@$values['ldap_user_create_ldap_acct']) {
    $ldap_user_conf = ldap_user_conf();
    $ldap_user = ldap_servers_get_user_ldap_data($drupal_username, $ldap_user_conf->ldapEntryProvisionServer, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, LDAP_USER_SYNCH_CONTEXT_MANUAL_LDAP_CREATE); 
    if ($ldap_user) {
      $tokens = array('%dn' => $ldap_user['dn'], '%name' => $drupal_username);
      form_set_error('ldap_user_create_ldap_acct', t('User %name already has a corresponding LDAP Entry (%dn).
        Uncheck "Create corresponding LDAP entry" to allow this Drupal user to be created.  Select
        "Make this an LDAP associated account" to associate this account with the ldap entry.', $tokens));
    }
  }
}



function ldap_user_form_register_form_submit1($form, &$form_state) {
  //dpm('ldap_user_form_register_form_submit1'); dpm($form); dpm($form_state);
  if (isset($form_state['values']['pass']) && $form_state['values']['pass']) {
    ldap_user_ldap_provision_semaphore('set_user_pass', NULL, $form_state['values']['pass']);
  }


}

/** called after user_register_form_submit **/
function ldap_user_form_register_form_submit2($form, &$form_state) {
  
  if (@$values['ldap_user_association'] == LDAP_USER_MANUAL_ACCT_CONFLICT_LDAP_ASSOCIATE) {
    $ldap_user_conf->ldapAssociateDrupalAccount($form_state['values']['name']);
  }
  
}


/**
 * api function for synching
 * note: does no checking if synching is enabled or configured for a given context
 */

function ldap_user_synch($username, $synch_context, $ldap_user = NULL) {
  $ldap_user_conf = ldap_user_conf();
  
  $account = user_load_by_name($username);
  $user_edit = array();
  //debug('ldap_user_synch() function in ldap_user.module');
  $ldap_user_conf->synchToDrupalAccount($account, $user_edit, $synch_context, $ldap_user, FALSE);
}

/**
 * api function for ldap associated user provisioning
 * note: does no checking if synching is enabled or configured for a given context
 */
function ldap_user_provision($ldap_user, $user_edit = array()) {
  $sid = $ldap_user['sid'];
  $ldap_user_conf = ldap_user_conf();
  $account = NULL;
  $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, $ldap_user, TRUE);
}




/**
 * function to protect unencrypted user password from:
 *   other modules
 *   multiple page requests
 *   serialization of user password in user object
 *   multiple synch or provisions to ldap in a single page request (...and potentially recursion)
 *
 *   @param enum string $action 'synch' | 'provision' | 'set_page_load_key' | NULL
 *   @param enum string $op
 *     'set_user_pass'  |
 *     'get_user_pass'  |
 *     'user_action_query' |
 *     'user_action_mark'
 *   @value mixed value associate with $op.
 */


function ldap_user_ldap_provision_semaphore($action, $op, $value = NULL) {
  
  $calling_function = FALSE;
  if (function_exists('debug_backtrace') && $backtrace = debug_backtrace()) { //   {
    $calling_function = $backtrace[1]['function'];
  }

  static $ldap_accts; 
  static $page_load_key;
  static $current_user_pass;
  static $intialized;

  if ($action == 'set_page_load') {//  correct calling functions should be ldap_user_init) {
    $page_load_key = user_password(); // get something random
    $ldap_accts  = array();
    $current_user_pass = NULL;
    $intialized = TRUE;
    return;
  }
  elseif (!$intialized) {
    watchdog('ldap_user', 'ldap_user_ldap_provision_semaphore used without initialization', array(), WATCHDOG_ERROR);
  }
 
   // mark that the given drupal user has had ldap entry synched or provisioned on this page load. 
  if ($op == 'user_action_mark') {
    if ($action && $value) {
      $ldap_accts[$action][$value] = TRUE;
    }
    return;
  }
  
  // has the given drupal user had ldap entry synched or provisioned on this page load.
  if ($op == 'user_action_query') {
    if ($action && $value && isset($ldap_accts[$action][$value])) {
      return  $ldap_accts[$action][$value];
    }
    else {
      return FALSE;
    }  
  }
  
  if ($action == 'set_user_pass') {
    $current_user_pass = $value;
  }
  elseif ($action == 'get_user_pass') {
    if (
        (!$calling_function || $calling_function == 'ldap_servers_token_tokenize_user_account')
        &&
        $current_user_pass
        ) { // and viable calling function is ldap_servers_token_tokenize_user_account
      return $current_user_pass;
    }
    else {
      return FALSE;
    }
  }
  
}


/**
 * Implements hook_user_login().
 */
function ldap_user_user_login(&$edit, $account) {
  
  if ($account->uid == 1) {
    return; // do not provision or synch user 1
  }
  $ldap_user_conf = ldap_user_conf();
  $user_edit = array();
  
   // provision or synch to ldap, not both
  $provision_result = array('status' => 'none');
  
  if (
      $ldap_user_conf->provisionsLdapEntriesFromDrupalUsers
      && ldap_user_ldap_provision_semaphore('provision', 'user_action_query', $account->name) === FALSE
      && !$ldap_user_conf->getProvisionRelatedLdapEntry($account)
      && $ldap_user_conf->ldapEntryProvisionServer != LDAP_USER_NO_SERVER_SID
      && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')
      ) {
    $provision_result = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, array());
  }
  // don't synch if just provisioned
  if (
    $ldap_user_conf->provisionsLdapEntriesFromDrupalUsers
    && ldap_user_ldap_provision_semaphore('synch', 'user_action_query' , $account->name) === FALSE
    && $provision_result['status'] != 'success'
    && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')
    ) {
    $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER);
  }
  
}


/**
 * Implements hook_user_insert().
 *
 */
function ldap_user_user_insert(&$user_edit, $account, $category) {

  //dpm('ldap_user_user_insert'); dpm($user_edit); dpm($account); // ldap_user_user_insert, category='. $category . 'account->status = ' . $account->status);

  if ($category == 'ldap_user' || (is_object($account) && property_exists($account, 'uid') && $account->uid == 1)) {
    return; // do not provision or synch user 1
  }
  
  $ldap_user_conf = ldap_user_conf();
  /**
   * in hook_user_insert, account is already created, so never call provisionDrupalAccount(), just
   * synchToDrupalAccount(), even if action is 'provision'
   */
  $empty_user_edit = array();
  if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) {
    $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
  }
  elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) {
    $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, NULL, TRUE);
  }
  elseif ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'synch')) {
    $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
  }
  elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'synch')) {
    $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, NULL, TRUE);
  }
    
  if ($ldap_user_conf->provisionsLdapEntriesFromDrupalUsers) {
    $already_provisioned_to_ldap = ldap_user_ldap_provision_semaphore('provision', 'user_action_query' , $account->name);
    $already_synched_to_ldap = ldap_user_ldap_provision_semaphore('synch', 'user_action_query' , $account->name);
  
     // provision or synch, not both
    $ldap_provision_entry = $ldap_user_conf->getProvisionRelatedLdapEntry($account);
    if ($already_provisioned_to_ldap === FALSE && !$ldap_provision_entry && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')) {
      $discard = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, array());
    }
    elseif ($already_provisioned_to_ldap === FALSE  && !$ldap_provision_entry && $account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')) {
      $discard = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, array());
    }
    elseif ($already_synched_to_ldap === FALSE && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
      $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);
    }
    elseif ($already_synched_to_ldap  === FALSE && $account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
      $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER);
    }
  }

}


/**
 * Implements hook_user_update().
 */
function ldap_user_user_update(&$user_edit, $account, $category) {
  //dpm("ldap_user_user_update, category=$category"); dpm($user_edit); dpm($account); // ldap_user_user_insert, category='. $category . 'account->status = ' . $account->status);


  if ($category == 'ldap_user' || (is_object($account) && property_exists($account, 'uid') && $account->uid == 1)) {
    return; // do not provision or synch user 1
  }

  $ldap_user_conf = ldap_user_conf();
  if ($ldap_user_conf->provisionsLdapEntriesFromDrupalUsers) {
    $provision_result = array('status' => 'none');
    $ldap_entry = $ldap_user_conf->getProvisionRelatedLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER);

    if (!$ldap_entry && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) { //{
      $provision_result = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, array());
    }

    // synch if not just provisioned and enabled
    if ($provision_result['status'] != 'success') {
      if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
        $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER);
      }
    }
  }
  
}


/**
 * Implements hook_user_delete().
 */
function ldap_user_user_delete($account) {
  // drupal user account is about to be deleted.  @todo.  check if ldap account needs to be deleted also
  $ldap_user_conf = ldap_user_conf();
  if (
      $ldap_user_conf->provisionsLdapEntriesFromDrupalUsers
      && $ldap_user_conf->contextEnabled(LDAP_USER_LDAP_ENTRY_DELETE_ON_USER_DELETE, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'delete_ldap_entry')
      && $ldap_entry = $ldap_user_conf->getProvisionRelatedLdapEntry($account)
      ) {
    $ldap_user_conf->deleteProvisionedLdapEntries($account);
  }

}



/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_provisioned_sid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_puid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_puid
 */
function ldap_user_puid_property_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_dn
 */
function ldap_user_dn_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * Implements hook_field_widget_info().
 * to provide field type for LDAP fields
 */
function ldap_user_field_widget_info() {
  return array(
    'ldap_user_hidden' => array(
      'label' => t('Hidden Text Field'),
      'field types' => array('text'),
      'settings' => array(),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function ldap_user_field_widget_settings_form($field, $instance) {
  return array();
}

/**
 * Implements hook_field_widget_form().
 */
function ldap_user_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $main_widget = array();

  switch ($instance['widget']['type']) {
    case 'ldap_user_hidden':
      $element['value'] = $element + array(
        '#type' => 'hidden',
        '#default_value' => isset($items[$delta]['value']) ? $items[$delta]['value'] : NULL,
      );
      break;
  }

  return $element;
}


function ldap_user_synch_contexts_key_values() {

  return array(
    LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER => 'Insert Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER => 'Update Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER => 'Authenticate Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_CRON => 'Cron Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER => 'Delete Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER => 'Disable Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER => 'User created with status enabled or User status changed to 1',
    LDAP_USER_SYNCH_CONTEXT_LDAP_ASSOCIATE => 'Existing user is being associated with existing LDAP entry',
    LDAP_USER_SYNCH_CONTEXT_MANUAL_LDAP_CREATE => 'Drupal account and LDAP Account are being created by add user form',
  );
  
}


function ldap_user_synch_contexts() {
  return array_keys(ldap_user_synch_contexts_key_values());
}


function ldap_user_synch_context_text($synch_context) {

  $contexts = ldap_user_synch_contexts_key_values();
  return $contexts[$synch_context];

}

function ldap_user_provision_contexts() {

  return array(
    LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_CRON,
    LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER,
    LDAP_TEST_QUERY_CONTEXT,
  );

}


/**
 * @param array $account
 * @param string $text
 * @return string text with tokens replaced
 */

function ldap_user_token_replace($token, $account, $entity = NULL) {
  $desired_tokens = ldap_servers_token_tokens_needed_for_template($token);
  $tokens = ldap_user_token_tokenize_entry($account, $desired_tokens, LDAP_SERVERS_TOKEN_PRE, LDAP_SERVERS_TOKEN_POST, $entity);
  $result = str_replace(array_keys($tokens), array_values($tokens), $token);
  return $result;
}



/**
 * Turn an ldap entry into a token array suitable for the t() function
 * @param drupal user object $account
 * @param array $token_keys as list of token/value pairs to generate
 * @param string prefix token prefix such as !,%,[
 * @param string suffix token suffix such as ]
 *
 * @return token array suitable for t() functions of with lowercase keys as exemplified below
 */
function ldap_user_token_tokenize_entry($account, $token_keys, $pre = LDAP_SERVERS_TOKEN_PRE, $post = LDAP_SERVERS_TOKEN_POST, $user_entity = NULL) {

  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $tokens = array();
  if (!$user_entity) {
    list($discard, $user_entity) = ldap_user_load_user_acct_and_entity($account->uid, 'uid');
  }

  foreach ($token_keys as $token_key) {
    // target id is of form field.lname, property.mail, field.dept:0, etc.
    list($type, $attr_ordinal) = explode('.', $token_key);
    $parts = explode(':', $attr_ordinal);
    $attr = $parts[0];
    $ordinal = (count($parts) > 1) ? $parts[1] : 0;
    $token = $pre . $token_key . $post;
    switch ($type) {

      case 'field':
        if (isset( $user_entity->{$attr}['und'][$ordinal]['value'])) {
          $tokens[$token] = $user_entity->{$attr}['und'][$ordinal]['value'];
        }
      break;


      case 'property':
        if (property_exists($account, $attr)) {
          $tokens[$token] = $account->{$attr};
        }
       break;

      // @todo: 3. tokenize profile 2
    }

  }

  return $tokens;
}

  /**
   * load user $account and $entity, given uid or $username
   *
   * @param string $user_id is username or uid
   * @param enum $user_id_type is 'username' or 'uid'
   *
   * return array $account and $user_entity
   */

  function ldap_user_load_user_acct_and_entity($user_id, $user_id_type = 'username') {

    if ($user_id_type == 'username') {
      $account = user_load_by_name($user_id);
    }
    else {
      $account = user_load($user_id);
    }
    if ($account) {
      $user_entities = entity_load('user', array($account->uid));
      $user_entity = $user_entities[$account->uid];
    }
    else {
      $user_entity = NULL;
    }

    return array($account, $user_entity);

  }