<?php

/**
 * @file
 * Module for the LDAP User Entity
 *
 */

define('LDAP_USER_DRUPAL_HELP_URL', 'http://drupal.org/node/997082');

define('LDAP_USER_PROV_ON_LOGON', 1);
define('LDAP_USER_PROV_ON_MANUAL_ACCT_CREATE', 2);
define('LDAP_USER_PROV_ON_ALL_USER_CREATION', 3);
define('LDAP_USER_PROV_CANCEL_DRUPAL_USER_ON_LDAP_ENTRY_MISSING', 4);
define('LDAP_USER_PROV_DELETE_DRUPAL_USER_ON_LDAP_ENTRY_MISSING', 5);

define('LDAP_USER_LDAP_ENTRY_CREATION_ON_CREATE', 1);
define('LDAP_USER_LDAP_ENTRY_DELETION_ON_DELETE', 2);

define('LDAP_USER_PROVISION_LDAP_ENTRY_EXISTS', 1);
define('LDAP_USER_PROVISION_LDAP_ENTRY_CREATE_FAILED', 2);
define('LDAP_USER_PROVISION_LDAP_ENTRY_SYNCH_FAILED', 3);

define('LDAP_USER_CONFLICT_LOG', 1);
define('LDAP_USER_CONFLICT_RESOLVE', 2);
define('LDAP_USER_CONFLICT_RESOLVE_DEFAULT', 2);

define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR', 4);
define('LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP', 1);
define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR_DEFAULT', 4);

define('LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY', 2);
define('LDAP_USER_SYNCH_DIRECTION_NONE', 3);

define('LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER', 2);
define('LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER', 3);
define('LDAP_USER_SYNCH_CONTEXT_CRON', 4);
define('LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER', 5);
define('LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER', 6);


define('LDAP_USER_TEST_FORM_PATH', 'admin/config/people/ldap/user/test');

define('LDAP_USER_WS_USER_PATH', 'ldap/user/ws');


/**
 * Implements hook_menu().
 */
function ldap_user_menu() {
  $items = array();

  $items['admin/config/people/ldap/user'] = array(
    'title' => '3. User',
    'description' => 'Settings related to user provisioning and data synching between ldap and drupal users.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'ldap_user.admin.inc',
  );

  $items[LDAP_USER_TEST_FORM_PATH] = array(
    'title' => 'Test LDAP User Functionality for a given user.',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_test_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ldap_user.test_form.inc',
  );

  $ws_arg_start = count(explode('/', LDAP_USER_WS_USER_PATH));
  $items[LDAP_USER_WS_USER_PATH] = array(
    'title' => 'Webservice Path',
    'page callback' => 'ldap_user_ws',
    'page arguments' => array($ws_arg_start, $ws_arg_start + 1, $ws_arg_start + 2),
    'access arguments' => array('view content'),
    'file' => 'ldap_user.ws.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ldap_user_theme() {
  return array('ldap_user_conf_form' => array(
    'render element' => 'form',
    'file' => 'ldap_user.theme.inc'
    ),
  );
}

/**
 * get ldapUserConf or ldapUserConfAdmin object
 *
 * @param enum $type is 'admin' for ldapUserConfAdmin object or NULL for ldapUserConf object
 * @param boolean $resect clear static cache of object.
 *
 * @return object ldapUserConf or ldapUserConfAdmin object
 */
function ldap_user_conf($type = NULL, $reset = FALSE) {
  static $ldap_user_conf;
  static $ldap_user_conf_admin;

  if ($type == 'admin' && ($reset || !is_object($ldap_user_conf_admin))) {
    ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConfAdmin.class');
    $ldap_user_conf_admin = new LdapUserConfAdmin();
  }
  elseif ($type != 'admin' && ($reset || !is_object($ldap_user_conf))) {
      ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConf.class');
    $ldap_user_conf = new LdapUserConf();
  }

  return ($type == 'admin') ? $ldap_user_conf_admin : $ldap_user_conf;
}


/**
 * implements hook_ldap_attributes_needed_alter().
 */
function ldap_user_ldap_attributes_needed_alter(&$attributes, $synch_context, $ldap_server) {

  //@todo need to load all ldap_user attributes used in synch mapping and add to list based on synch context.
 // // temp_out dpm("ldap_user_ldap_attributes_needed_alter"); // temp_out dpm($attributes); // temp_out dpm($ldap_server); // temp_out dpm($sych_context);
  $attributes[] = 'dn';
  if ($ldap_server) { // puid attributes are server specific
    if (is_scalar($ldap_server)) {
      $ldap_server = ldap_servers_get_servers($ldap_server, 'enabled', TRUE);
    }

    switch ($synch_context) {
      case LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER:
          // Load the user configuration.
        $conf = ldap_user_conf();
        // Add the attributes required by the user configuration.
        $attributes += $conf->getRequiredAttributes($synch_context);
        $attributes[] = $ldap_server->user_attr;
        $attributes[] = $ldap_server->mail_attr;
        ldap_servers_extract_attributes_from_token($attributes,  $ldap_server->mail_template);
        $attributes[] = $ldap_server->unique_persistent_attr;
      break;

    }
  }
}


/**
 * implements hook_ldap_user_attrs_list_alter()
 *
 */
function ldap_user_ldap_user_attrs_list_alter(&$available_user_attrs, &$ldap_server, $ldap_user_conf) {

  $sid = $ldap_server->sid;
  $tokens = array(
    '!edit_link' => l($ldap_server->editPath, $ldap_server->editPath),
  );



  // 1. Drupal user properties
  // 1.a make sure empty array are present so array + function works
  foreach (array('property.status','property.timezone','property.signature') as $i => $property_id) {
    if (!isset($available_user_attrs[$property_id]) || !is_array($available_user_attrs[$property_id])) {
      $available_user_attrs[$property_id] = array();
    }
  }
  //@todo make these merges so they don't override saved values such as 'enabled'
  $available_user_attrs['property.status'] = $available_user_attrs['property.status'] + array(
    'name' => 'Property: Acount Status',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'user_tokens' => '1=enabled, 0=blocked.',
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['property.timezone'] = $available_user_attrs['property.timezone'] + array(
    'name' => 'Property: User Timezone',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['property.signature'] = $available_user_attrs['property.signature'] + array(
    'name' => 'Property: User Signature',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  // 2. Drupal user fields
  $user_fields = field_info_instances('user', 'user');
  foreach ($user_fields as $field_name => $field_instance) {
    $field_id = "field.$field_name";
    if (!isset($available_user_attrs[$field_id]) || !is_array($available_user_attrs[$field_id])) {
      $available_user_attrs[$field_id] = array();
    }
   // dpm($field_id);
   // dpm($available_user_attrs[$field_id]);
    $available_user_attrs[$field_id] = $available_user_attrs[$field_id] + array(
      'name' => t('Field: '). $field_instance['label'],
      'configurable_to_drupal' => 1,
      'configurable_to_ldap' => 1,
      'enabled' => FALSE,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
    );
  //  dpm($available_user_attrs[$field_id]);

  //  dpm($field_id); dpm($available_user_attrs[$field_id]);
  }

  $configurable_to_drupal = (int)($ldap_user_conf->provisionsDrupalAccountsFromLdap) ? 0 : 1;
  $available_user_attrs['property.name'] = array(
    'configurable_to_drupal' => $configurable_to_drupal,
    'configurable_to_ldap' => 1,
    );

  $available_user_attrs['property.mail'] = array(
    'configurable_to_drupal' => $configurable_to_drupal,
    'configurable_to_ldap' => 1,
    );

  if (!$ldap_user_conf->provisionsDrupalAccountsFromLdap) {
    $available_user_attrs['property.mail']['config_module'] = 'ldap_user';
    $available_user_attrs['property.name']['config_module'] = 'ldap_user';
  }

  //this is where  need to be added to arrays
  // temp_out dpm("sic=$sid, ldap_user_ldap_user_attrs_list_alter, ldapUserSynchMappings: "); // temp_out dpm($ldap_user_conf->ldapUserSynchMappings[$sid]);
  if (isset($ldap_user_conf->ldapUserSynchMappings[$sid])) {
    foreach ($ldap_user_conf->ldapUserSynchMappings[$sid] as $target_attribute => $mapping) {
      //// temp_out dpm($target_attribute); // temp_out dpm($mapping);
      if (isset($mapping['direction']) && $mapping['direction'] == LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER && isset($mapping['user_attr'])) {
        $key = $mapping['user_attr'];
      }
      elseif (isset($mapping['direction']) && $mapping['direction'] == LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY && isset($mapping['ldap_attr'])) {
        $key = $mapping['ldap_attr'];
      }
      else {
        continue;
      }


      foreach (array('sid','ldap_attr','user_attr','convert','direction','enabled','contexts') as $k) {
        if (isset($mapping[$k])) {
          $available_user_attrs[$key][$k] = $mapping[$k];
        }
        else {
          $available_user_attrs[$key][$k] = NULL;
        }
        $available_user_attrs[$key]['config_module'] = 'ldap_user';
        $available_user_attrs[$key]['synch_module'] = 'ldap_user';
      }

    }
  }

  // temp_out dpm('available_user_attrs'); // temp_out dpm($available_user_attrs);  // temp_out dpm("ldap_user_conf->ldapUserSynchMappings[sid]");  // temp_out dpm($ldap_user_conf->ldapUserSynchMappings[$sid]);

  //    'notes' => 'configure at '. $server_edit_path,

 // // temp_out dpm('available_user_attrs'. $configurable_to_drupal); // temp_out dpm($available_user_attrs);// temp_out dpm("provisionsDrupalAccountsFromLdap=" . $provisionsDrupalAccountsFromLdap);
  // 3. profile2 fields



  // 4. $user->data array.   will need to be added manually.  perhaps better not to implement this at all?


}
/**
 * Implements hook_help().
 */

function ldap_user_help($path, $arg) {

  $ldap_user_help = t('LDAP user configuration determines how and when
    Drupal accounts are created based on LDAP data and which user fields
    are derived and synched to and from LDAP. See !helplink.',
    array(
      '!helplink' => l(LDAP_USER_DRUPAL_HELP_URL, LDAP_USER_DRUPAL_HELP_URL),
    ));

  switch ($path) {
    case 'admin/config/people/ldap/user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;

    case 'admin/help#ldap_user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;
  }
}


/**
 * api function for synching
 */

function ldap_user_synch($username, $synch_context, $ldap_user = NULL) {
  $ldap_user_conf = ldap_user_conf();
  $account = user_load_by_name($username);
  $user_edit = array();
  $ldap_user_conf->synchToDrupalAccount($account, $user_edit, $synch_context, $ldap_user, FALSE);
}

/**
 * api function for ldap associated user provisioning
 */
function ldap_user_provision($ldap_user, $user_edit = array()) {
  $sid = $ldap_user['sid'];
  $ldap_user_conf = ldap_user_conf();
  $account = NULL;
  $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, $ldap_user, TRUE);
}


/**
 * Implements hook_user_login().
 */
function ldap_user_user_login(&$edit, $account) {
  $ldap_user_conf = ldap_user_conf();
  $user_edit = array();
  /** synching of attributes between drupal and ldap is configured per attribute.  so call to synch is always
      made even if no synching occurs.
  **/
  $ldap_user_conf->synchToDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, NULL, FALSE);
  $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, NULL, FALSE);
}

/**
 * Implements hook_user_presave().
*/
function ldap_user_user_presave(&$user_edit, $account, $category) {
  $ldap_user_conf = ldap_user_conf();
  $synch_context = $account->is_new ? LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER : LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER;
  // Update the Drupal user object from the LDAP account.
  $ldap_user_conf->synchToDrupalAccount($account, $user_edit, $synch_context, NULL, FALSE);
  // Make sure we've not removed the email address.
  if (empty($user_edit['mail']) && !empty($account->mail)) {
    // Use the original value.
    $user_edit['mail'] = $account->mail;
  }
}

/**
 * Implements hook_user_insert().
 *
 */
function ldap_user_user_insert(&$user_edit, $account, $category) {

  $ldap_user_conf = ldap_user_conf();
  $synch_context = LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER;

  if ($account->status && in_array(LDAP_USER_LDAP_ENTRY_CREATION_ON_CREATE, $ldap_user_conf->ldapEntryProvisionEvents)) {
    $results = $ldap_user_conf->provisionLdapEntry($account, $synch_context);
  }

  $ldap_user_conf->synchToLdapEntry($account, $user_edit, $synch_context, NULL, FALSE);
}


/**
 * Implements hook_user_update().
 */
function ldap_user_user_update(&$user_edit, $account, $category) {

  $ldap_user_conf = ldap_user_conf();
  $synch_context = LDAP_USER_LDAP_ENTRY_CREATION_ON_CREATE;

  $status_enabled =  ($account->original->status != $account->status && $account->status == 1);
  if ($status_enabled && in_array(LDAP_USER_LDAP_ENTRY_CREATION_ON_CREATE, $ldap_user_conf->ldapEntryProvisionEvents)) {
    $result = $ldap_user_conf->provisionLdapEntry($account, $synch_context);
  }

  $ldap_user_conf->synchToLdapEntry($account, $user_edit, $synch_context, NULL, FALSE);
}


/**
 * Implements hook_user_delete().
 */
function ldap_user_user_delete($account) {
  // drupal user account is about to be deleted.  @todo.  check if ldap account needs to be deleted also
  $ldap_user_conf = ldap_user_conf();
  $user_edit = array();
  if (in_array(LDAP_USER_LDAP_ENTRY_DELETION_ON_DELETE, $ldap_user_conf->ldapEntryProvisionEvents)) {
    $ldap_user_conf->deleteCorrespondingLdapEntry($account);
  }

}



/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_provisioned_sid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_puid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_puid
 */
function ldap_user_puid_property_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_dn
 */
function ldap_user_dn_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * Implements hook_field_widget_info().
 * to provide field type for LDAP fields
 */
function ldap_user_field_widget_info() {
  return array(
    'ldap_user_hidden' => array(
      'label' => t('Hidden Text Field'),
      'field types' => array('text'),
      'settings' => array(),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function ldap_user_field_widget_settings_form($field, $instance) {
  return array();
}

/**
 * Implements hook_field_widget_form().
 */
function ldap_user_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $main_widget = array();

  switch ($instance['widget']['type']) {
    case 'ldap_user_hidden':
      $element['value'] = $element + array(
        '#type' => 'hidden',
        '#default_value' => isset($items[$delta]['value']) ? $items[$delta]['value'] : NULL,
      );
      break;
  }

  return $element;
}



/**
 * Implements hook_permission().
 */
function ldap_user_permission() {
  // We set up permisssions to manage entity types, manage all entities and the
  // permissions for each individual entity
  $permissions = array(
    'administer ldap users' => array(
      'title' => t('Create, Edit and Delete LDAP Provisioned Users'),
      'description' => t('Create, Edit and Delete LDAP Provisioned Users'),
    ),
    'edit user ldap fields' => array(
      'title' => t('Edit User LDAP Fields'),
      'description' => t('Edit User LDAP Fields'),
    ),
  );

  return $permissions;
}


/** this function may be headed nowhere
 * these constants may just need to replaced by
 * an enum list of such as 'insert', 'update', 'authenticate'
 * to give more flexibility and better code readability.
 */
function ldap_user_all_contexts() {

  return array(
    LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_CRON,
    LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER,
    LDAP_TEST_QUERY_CONTEXT,
  );


}
