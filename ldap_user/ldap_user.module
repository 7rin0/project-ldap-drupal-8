<?php

/**
 * @file
 * Module for the LDAP User Entity
 *
 */

define('LDAP_USER_DRUPAL_HELP_URL', 'http://drupal.org/node/997082');

// configurable states where synch or provision to drupal user could occur
define('LDAP_USER_DRUPAL_USER_CREATE_ON_LOGON', 1);
define('LDAP_USER_DRUPAL_USER_CREATE_ON_MANUAL_ACCT_CREATE', 2);
define('LDAP_USER_DRUPAL_USER_CREATE_ON_ALL_USER_CREATION', 3);
define('LDAP_USER_DRUPAL_USER_UPDATE_ON_USER_AUTHENTICATE', 6);
define('LDAP_USER_DRUPAL_USER_UPDATE_ON_USER_UPDATE', 7);
define('LDAP_USER_DRUPAL_USER_CANCEL_ON_LDAP_ENTRY_MISSING', 4);
define('LDAP_USER_DRUPAL_USER_DELETE_ON_LDAP_ENTRY_MISSING', 5);

// configurable states where synch or provision to ldap entry could occur
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_STATUS_IS_1', 2);
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_UPDATE', 3);
define('LDAP_USER_LDAP_ENTRY_CREATE_ON_USER_AUTHENTICATE', 4);
define('LDAP_USER_LDAP_ENTRY_UPDATE_ON_USER_UPDATE', 5);
define('LDAP_USER_LDAP_ENTRY_UPDATE_ON_USER_AUTHENTICATE', 6);
define('LDAP_USER_LDAP_ENTRY_DELETE_ON_USER_DELETE', 7);

// results of ldap entry provisioning
define('LDAP_USER_PROVISION_LDAP_ENTRY_EXISTS', 1);
define('LDAP_USER_PROVISION_LDAP_ENTRY_CREATE_FAILED', 2);
define('LDAP_USER_PROVISION_LDAP_ENTRY_SYNCH_FAILED', 3);

define('LDAP_USER_CONFLICT_LOG', 1);
define('LDAP_USER_CONFLICT_RESOLVE', 2);
define('LDAP_USER_CONFLICT_RESOLVE_DEFAULT', 2);

define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR', 4);
define('LDAP_USER_ACCT_CREATION_USER_SETTINGS_FOR_LDAP', 1);
define('LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR_DEFAULT', 4);

define('LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY', 2);
define('LDAP_USER_SYNCH_DIRECTION_NONE', 3);

// SYNCH CONTEXTS are actions which may cause provisioning or synching of drupal accounts or ldap entries
define('LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER', 1);
define('LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER', 2);
define('LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER', 3);
define('LDAP_USER_SYNCH_CONTEXT_CRON', 4);
define('LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER', 5);
define('LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER', 6);
define('LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER', 7);

define('LDAP_USER_NO_SERVER_SID', 'NULLNULL');

define('LDAP_USER_TEST_FORM_PATH', 'admin/config/people/ldap/user/test');

define('LDAP_USER_WS_USER_PATH', 'ldap/user/ws');


/**
 * Implements hook_menu().
 */
function ldap_user_menu() {
  $items = array();

  $items['admin/config/people/ldap/user'] = array(
    'title' => '3. User',
    'description' => 'Settings related to user provisioning and data synching between ldap and drupal users.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_admin_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'ldap_user.admin.inc',
  );

  $items[LDAP_USER_TEST_FORM_PATH] = array(
    'title' => 'Test LDAP User Functionality for a given user.',
    'description' => '',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ldap_user_test_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'ldap_user.test_form.inc',
    'type' => MENU_LOCAL_ACTION,
  );

  $ws_arg_start = count(explode('/', LDAP_USER_WS_USER_PATH));
  $items[LDAP_USER_WS_USER_PATH] = array(
    'title' => 'Webservice Path',
    'page callback' => 'ldap_user_ws',
    'page arguments' => array($ws_arg_start, $ws_arg_start + 1, $ws_arg_start + 2),
    'access arguments' => array('view content'),
    'file' => 'ldap_user.ws.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ldap_user_theme() {
  return array('ldap_user_conf_form' => array(
    'render element' => 'form',
    'file' => 'ldap_user.theme.inc'
    ),
  );
}

function ldap_user_conf_cache_clear() {
  $discard = ldap_user_conf('admin', TRUE);
  $discard = ldap_user_conf(NULL, TRUE);
}

/**
 * get ldapUserConf or ldapUserConfAdmin object
 *
 * @param enum $type is 'admin' for ldapUserConfAdmin object or NULL for ldapUserConf object
 * @param boolean $resect clear static cache of object.
 *
 * @return object ldapUserConf or ldapUserConfAdmin object
 */
function ldap_user_conf($type = NULL, $reset = FALSE) {
  static $ldap_user_conf;
  static $ldap_user_conf_admin;

  if ($type == 'admin' && ($reset || !is_object($ldap_user_conf_admin))) {
    ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConfAdmin.class');
    $ldap_user_conf_admin = new LdapUserConfAdmin();
  }
  elseif ($type != 'admin' && ($reset || !is_object($ldap_user_conf))) {
    ldap_server_module_load_include('php', 'ldap_user', 'LdapUserConf.class');
    $ldap_user_conf = new LdapUserConf();
  }

  return ($type == 'admin') ? $ldap_user_conf_admin : $ldap_user_conf;
}


/**
 * implements hook_ldap_attributes_needed_alter().
 */
function ldap_user_ldap_attributes_needed_alter(&$attributes, $synch_context, $ldap_server) {
  // debug("ldap_user_ldap_attributes_needed_alter synch_context=$synch_context");
  //@todo need to load all ldap_user attributes used in synch mapping and add to list based on synch context.
 // // temp_out dpm("ldap_user_ldap_attributes_needed_alter"); // temp_out dpm($attributes); // temp_out dpm($ldap_server); // temp_out dpm($sych_context);
  
  if ($ldap_server) { // puid attributes are server specific
    if (is_scalar($ldap_server)) {
      $ldap_server = ldap_servers_get_servers($ldap_server, 'enabled', TRUE);
    }

    $ldap_user_conf = ldap_user_conf();
    $attributes[] = 'dn';
    switch ($synch_context) { // Add the attributes required by the user configuration when provisioning drupal users
      case LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER:
        $attributes[] = $ldap_server->user_attr; 
        $attributes[] = $ldap_server->mail_attr;
        $attributes[] = $ldap_server->unique_persistent_attr;
        if ($ldap_server->mail_template) {
          ldap_servers_token_extract_attributes($attributes,  $ldap_server->mail_template);  
        }
      break;  
        
      case LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_CRON:
      case LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER:
      case LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER:
      case LDAP_TEST_QUERY_CONTEXT:
    

      break;

    }
    
    $attributes_required_by_user_module_mappings = $ldap_user_conf->getRequiredAttributes($synch_context);
    $attributes = array_unique(array_merge(array_values($attributes_required_by_user_module_mappings), $attributes));
   // debug('attributes2'); debug($attributes);
  }
}

/**
 * implements hook_ldap_user_attrs_list_alter()
 *
 */
function ldap_user_ldap_user_attrs_list_alter(&$available_user_attrs, &$params) {

  $ldap_server = $params['ldap_server'];
  $ldap_user_conf = $params['ldap_user_conf'];
  $direction = $params['direction']; 

  $sid = $ldap_server->sid;
  $tokens = array(
    '!edit_link' => l($ldap_server->editPath, $ldap_server->editPath),
  );

  // 1. Drupal user properties
  // 1.a make sure empty array are present so array + function works
  foreach (array('property.status','property.timezone','property.signature') as $i => $property_id) {
    $property_token = '[' . $property_id  .']';
    if (!isset($available_user_attrs[$property_token]) || !is_array($available_user_attrs[$property_token])) {
      $available_user_attrs[$property_token] = array();
    }
  }
  //@todo make these merges so they don't override saved values such as 'enabled'
  $available_user_attrs['[property.status]'] = $available_user_attrs['[property.status]'] + array(
    'name' => 'Property: Acount Status',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'user_tokens' => '1=enabled, 0=blocked.',
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['[property.timezone]'] = $available_user_attrs['[property.timezone]'] + array(
    'name' => 'Property: User Timezone',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  $available_user_attrs['[property.signature]'] = $available_user_attrs['[property.signature]'] + array(
    'name' => 'Property: User Signature',
    'configurable_to_drupal' => 1,
    'configurable_to_ldap' => 1,
    'enabled' => FALSE,
    'config_module' => 'ldap_user',
    'synch_module' => 'ldap_user',
  );

  // 2. Drupal user fields
  $user_fields = field_info_instances('user', 'user');
  foreach ($user_fields as $field_name => $field_instance) {
    $field_id = "[field.$field_name]";
    if (!isset($available_user_attrs[$field_id]) || !is_array($available_user_attrs[$field_id])) {
      $available_user_attrs[$field_id] = array();
    }
   // dpm($field_id);
   // dpm($available_user_attrs[$field_id]);
    $available_user_attrs[$field_id] = $available_user_attrs[$field_id] + array(
      'name' => t('Field: '). $field_instance['label'],
      'configurable_to_drupal' => 1,
      'configurable_to_ldap' => 1,
      'enabled' => FALSE,
      'config_module' => 'ldap_user',
      'synch_module' => 'ldap_user',
    );
  //  dpm($available_user_attrs[$field_id]);

  //  dpm($field_id); dpm($available_user_attrs[$field_id]);
  }

  $available_user_attrs['[property.name]'] = array(
    'configurable_to_drupal' => FALSE,
    'configurable_to_ldap' => 1,
    );

  $available_user_attrs['[property.mail]'] = array(
    'configurable_to_drupal' => FALSE,
    'configurable_to_ldap' => 1,
    );

  if (!$ldap_user_conf->provisionsDrupalAccountsFromLdap) {
    $available_user_attrs['[property.mail]']['config_module'] = 'ldap_user';
    $available_user_attrs['[property.name]']['config_module'] = 'ldap_user';
  }

  //this is where  need to be added to arrays
  // temp_out dpm("sic=$sid, ldap_user_ldap_user_attrs_list_alter, ldapUserSynchMappings: "); // temp_out dpm($ldap_user_conf->ldapUserSynchMappings[$sid]);
  if (isset($ldap_user_conf->ldapUserSynchMappings[$direction][$sid])) {
   // debug($ldap_user_conf->ldapUserSynchMappings[$sid]);
    foreach ($ldap_user_conf->ldapUserSynchMappings[$direction][$sid] as $target_token => $mapping) {
      //// temp_out dpm($target_attribute); // temp_out dpm($mapping);
      if ($direction == LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER && isset($mapping['user_attr'])) {
        $key = $mapping['user_attr'];
      }
      elseif ($direction == LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY && isset($mapping['ldap_attr'])) {
        $key = $mapping['ldap_attr'];
      }
      else {
        continue;
      }


      foreach (array('sid','ldap_attr','user_attr','convert','direction','enabled','contexts') as $k) {
        if (isset($mapping[$k])) {
          $available_user_attrs[$key][$k] = $mapping[$k];
        }
        else {
          $available_user_attrs[$key][$k] = NULL;
        }
        $available_user_attrs[$key]['config_module'] = 'ldap_user';
        $available_user_attrs[$key]['synch_module'] = 'ldap_user';
      }
      if ($mapping['user_attr'] == 'user_tokens') {
        $available_user_attrs['user_attr'] = $mapping['user_tokens'];
      }

    }
  }

  // temp_out dpm('available_user_attrs'); // temp_out dpm($available_user_attrs);  // temp_out dpm("ldap_user_conf->ldapUserSynchMappings[sid]");  // temp_out dpm($ldap_user_conf->ldapUserSynchMappings[$sid]);

  //    'notes' => 'configure at '. $server_edit_path,

 // // temp_out dpm('available_user_attrs'. $configurable_to_drupal); // temp_out dpm($available_user_attrs);// temp_out dpm("provisionsDrupalAccountsFromLdap=" . $provisionsDrupalAccountsFromLdap);
  // 3. profile2 fields



  // 4. $user->data array.   will need to be added manually.  perhaps better not to implement this at all?


}
/**
 * Implements hook_help().
 */

function ldap_user_help($path, $arg) {

  $ldap_user_help = t('LDAP user configuration determines how and when
    Drupal accounts are created based on LDAP data and which user fields
    are derived and synched to and from LDAP. See !helplink.',
    array(
      '!helplink' => l(LDAP_USER_DRUPAL_HELP_URL, LDAP_USER_DRUPAL_HELP_URL),
    ));

  switch ($path) {
    case 'admin/config/people/ldap/user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;

    case 'admin/help#ldap_user':
      $output = '<p>' . $ldap_user_help . '</p>';
      return $output;
  }
}


/**
 * api function for synching
 * note: does no checking if synching is enabled or configured for a given context
 */

function ldap_user_synch($username, $synch_context, $ldap_user = NULL) {
  $ldap_user_conf = ldap_user_conf();
  
  $account = user_load_by_name($username);
  $user_edit = array();
  //debug('ldap_user_synch() function in ldap_user.module');
  $ldap_user_conf->synchToDrupalAccount($account, $user_edit, $synch_context, $ldap_user, FALSE);
}

/**
 * api function for ldap associated user provisioning
 * note: does no checking if synching is enabled or configured for a given context
 */
function ldap_user_provision($ldap_user, $user_edit = array()) {
  $sid = $ldap_user['sid'];
  $ldap_user_conf = ldap_user_conf();
  $account = NULL;
  $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, $ldap_user, TRUE);
}


/**
 * Implements hook_user_login().
 */
function ldap_user_user_login(&$edit, $account) {
  $ldap_user_conf = ldap_user_conf();
  $user_edit = array();

   // provision or synch to ldap, not both
  $result = array('status' => 'none');
  if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')) {
    $provision_result = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER);
  }
  // don't synch if just provisioned
  if ($result['status'] != 'success' && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
    $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER);
  }
  
}

/**
 * Implements hook_user_presave().
 *
 * @todo this is probably a hook to eliminate, otherwise the synch command is called multiple times
 * stick to hook_user_update, hook_user_insert, hook_user_logon that are coupled with clear events.
*/
function ldap_user_user_presave(&$user_edit, $account, $category) {
  if ($category != 'ldap_user') { // avoid recursion
    
  //  $ldap_user_conf = ldap_user_conf();
  //  debug('ldap_user_user_presave');
  //  $synch_context = $account->is_new ? LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER : LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER;
    // Update the Drupal user object from the LDAP account.
    
   // $enabled = $ldap_user_conf->contextEnabled($synch_context, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'synch');
  //  debug('ldap_user_user_presave,enabled='. $enabled);
  //  if ($enabled) {
   //   $ldap_user_conf->synchToDrupalAccount($account, $user_edit, $synch_context);
  //  }
    // Make sure we've not removed the email address.
  //  if (empty($user_edit['mail']) && !empty($account->mail)) {
   //   // Use the original value.
   //   $user_edit['mail'] = $account->mail;
  //  }
  }
}

/**
 * Implements hook_user_insert().
 *
 */
function ldap_user_user_insert(&$user_edit, $account, $category) {
  // @todo.  need to consider how these might duplicate other provision and synch calls in same login, etc.
  //         this is best done via ldap user dev notes 
 // dpm($user_edit); dpm($account); // ldap_user_user_insert, category='. $category . 'account->status = ' . $account->status);
  if ($category != 'ldap_user') { // avoid recursion
    $ldap_user_conf = ldap_user_conf();
    
    /**
     * in hook_user_insert, account is already created, so never call provisionDrupalAccount(), just
     * synchToDrupalAccount(), even if action is 'provision'
     */
    $empty_user_edit = array();
    if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) {
      $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
    }
    elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) {
      $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, NULL, TRUE);
    }
    elseif ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'synch')) {
      $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
    }
    elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'synch')) {
      $ldap_user_conf->synchToDrupalAccount($account, $empty_user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, NULL, TRUE);
    }    
     // provision or synch, not both
    if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')) {
      $discard = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);
    }
    elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'provision')) {
      $discard = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER);
    }
    elseif ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
      $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);
    }
    elseif ($account->status && $ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
      $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER);
    } 
  }
  
}


/**
 * Implements hook_user_update().
 */
function ldap_user_user_update(&$user_edit, $account, $category) {
  if ($category != 'ldap_user') { // avoid recursion
    $ldap_user_conf = ldap_user_conf();

    $provision_result = array('status' => 'none');
    if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER, 'provision')) { //{
      $provision_result = $ldap_user_conf->provisionLdapEntry($account, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER);
    }
    // synch if not just provisioned and  enabled
    if ($provision_result['status'] != 'success') {
      if ($ldap_user_conf->contextEnabled(LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'synch')) {
        $bool_result = $ldap_user_conf->synchToLdapEntry($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER);
      }
    }
  }
}


/**
 * Implements hook_user_delete().
 */
function ldap_user_user_delete($account) {
  // drupal user account is about to be deleted.  @todo.  check if ldap account needs to be deleted also
  $ldap_user_conf = ldap_user_conf();
  if ($ldap_user_conf->contextEnabled(LDAP_USER_LDAP_ENTRY_DELETE_ON_USER_DELETE, LDAP_USER_SYNCH_DIRECTION_TO_LDAP_ENTRY, 'delete_ldap_entry')) {
    //debug('context enabled');
    $ldap_user_conf->deleteProvisionedLdapEntries($account);
  }
  else {
   // debug('context NOT enabled');
  }

}



/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_provisioned_sid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * @return default value for field user->ldap_user_provisioned_sid
 */
function ldap_user_puid_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_puid
 */
function ldap_user_puid_property_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}
/**
 * @return default value for field user->ldap_user_dn
 */
function ldap_user_dn_default($entity_type, $entity, $field, $instance, $langcode) {
  return NULL;
}

/**
 * Implements hook_field_widget_info().
 * to provide field type for LDAP fields
 */
function ldap_user_field_widget_info() {
  return array(
    'ldap_user_hidden' => array(
      'label' => t('Hidden Text Field'),
      'field types' => array('text'),
      'settings' => array(),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function ldap_user_field_widget_settings_form($field, $instance) {
  return array();
}

/**
 * Implements hook_field_widget_form().
 */
function ldap_user_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $main_widget = array();

  switch ($instance['widget']['type']) {
    case 'ldap_user_hidden':
      $element['value'] = $element + array(
        '#type' => 'hidden',
        '#default_value' => isset($items[$delta]['value']) ? $items[$delta]['value'] : NULL,
      );
      break;
  }

  return $element;
}



/**
 * Implements hook_permission().
 */
function ldap_user_permission() {
  // We set up permisssions to manage entity types, manage all entities and the
  // permissions for each individual entity
  $permissions = array(
    'administer ldap users' => array(
      'title' => t('Create, Edit and Delete LDAP Provisioned Users'),
      'description' => t('Create, Edit and Delete LDAP Provisioned Users'),
    ),
    'edit user ldap fields' => array(
      'title' => t('Edit User LDAP Fields'),
      'description' => t('Edit User LDAP Fields'),
    ),
  );

  return $permissions;
}


function ldap_user_synch_contexts_key_values() {

  return array(
    LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER => 'Insert Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER => 'Update Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER => 'Authenticate Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_CRON => 'Cron Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER => 'Delete Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER => 'Disable Drupal User Synch Context',
    LDAP_USER_SYNCH_CONTEXT_ENABLE_DRUPAL_USER => 'User created with status enabled or User status changed to 1',
  );
  
}




function ldap_user_synch_contexts() {
  return array_keys(ldap_user_synch_contexts_key_values());
}


function ldap_user_synch_context_text($synch_context) {

  $contexts = ldap_user_synch_contexts_key_values();
  return $contexts[$synch_context];

}

function ldap_user_provision_contexts() {

  return array(
    LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_CRON,
    LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER,
    LDAP_USER_SYNCH_CONTEXT_DISABLE_DRUPAL_USER,
    LDAP_TEST_QUERY_CONTEXT,
  );

}


/**
 * @param array $account
 * @param string $text
 * @return string text with tokens replaced
 */

function ldap_user_token_replace($token, $account, $entity = NULL) {
  $desired_tokens = ldap_servers_token_tokens_needed_for_template($token);
  $tokens = ldap_user_token_tokenize_entry($account, $desired_tokens, LDAP_SERVERS_TOKEN_PRE, LDAP_SERVERS_TOKEN_POST, $entity);
  $result = str_replace(array_keys($tokens), array_values($tokens), $token);
  return $result;
}



/**
 * Turn an ldap entry into a token array suitable for the t() function
 * @param drupal user object $account
 * @param array $token_keys as list of token/value pairs to generate
 * @param string prefix token prefix such as !,%,[
 * @param string suffix token suffix such as ]
 *
 * @return token array suitable for t() functions of with lowercase keys as exemplified below
 */
function ldap_user_token_tokenize_entry($account, $token_keys, $pre = LDAP_SERVERS_TOKEN_PRE, $post = LDAP_SERVERS_TOKEN_POST, $user_entity = NULL) {

  $detailed_watchdog_log = variable_get('ldap_help_watchdog_detail', 0);
  $tokens = array();
  if (!$user_entity) {
    list($discard, $user_entity) = ldap_user_load_user_acct_and_entity($account->uid, 'uid');
  }

  foreach ($token_keys as $token_key) {
    // target id is of form field.lname, property.mail, field.dept:0, etc.
    list($type, $attr_ordinal) = explode('.', $token_key);
    $parts = explode(':', $attr_ordinal);
    $attr = $parts[0];
    $ordinal = (count($parts) > 1) ? $parts[1] : 0;
    $token = $pre . $token_key . $post;
    switch ($type) {

      case 'field':
        if (isset( $user_entity->{$attr}['und'][$ordinal]['value'])) {
          $tokens[$token] = $user_entity->{$attr}['und'][$ordinal]['value'];
        }
      break;


      case 'property':
        if (property_exists($account, $attr)) {
          $tokens[$token] = $account->{$attr};
        }
       break;

      // @todo: 3. tokenize profile 2
    }

  }

  return $tokens;
}

  /**
   * load user $account and $entity, given uid or $username
   *
   * @param string $user_id is username or uid
   * @param enum $user_id_type is 'username' or 'uid'
   *
   * return array $account and $user_entity
   */

  function ldap_user_load_user_acct_and_entity($user_id, $user_id_type = 'username') {

    if ($user_id_type == 'username') {
      $account = user_load_by_name($user_id);
    }
    else {
      $account = user_load($user_id);
    }
    if ($account) {
      $user_entities = entity_load('user', array($account->uid));
      $user_entity = $user_entities[$account->uid];
    }
    else {
      $user_entity = NULL;
    }

    return array($account, $user_entity);


  }
