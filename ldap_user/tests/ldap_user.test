<?php
// $Id$

/**
 * @file
 * see getInfo() for test summary
 */


module_load_include('php', 'ldap_test', 'LdapUserTestCasev2.class');



class LdapUserUnitTests extends LdapUserTestCasev2 {
  public static function getInfo() {
    return array(
      'name' => 'LDAP User Tests: API and Function Tests v2',
      'description' => 'Test functions outside of real contexts (unit tests).',
      'group' => 'LDAP User'
    );
  }


  /**
   * make sure install succeeds and ldap user functions/methods work
   */
  function testFunctionsAndInstall() {

    $this->ldapTestId = $this->module_name . ': setup success';

    // just to give warning if setup doesn't succeed.  may want to take these out at some point.
    $setup_success = (
        module_exists('ldap_user') &&
        module_exists('ldap_servers') &&
        (variable_get('ldap_simpletest', 0) > 0)
      );
    $this->assertTrue($setup_success, ' ldap_user setup successful', $this->ldapTestId);


    $this->ldapTestId = $this->module_name . ': test for functions not changing';
    $api_functions = array(
      'ldap_user_conf' => array(2, 0),
      'ldap_user_synch' => array(3, 2),
      'ldap_user_provision' => array(2, 1),
    );

    foreach ($api_functions as $api_function_name => $param_count) {
      $reflector = new ReflectionFunction($api_function_name);
      $this->assertTrue(
        function_exists($api_function_name) &&
        $param_count[1] == $reflector->getNumberOfRequiredParameters() &&
        $param_count[0] == $reflector->getNumberOfParameters()
        , ' api function ' . $api_function_name . ' parameters and required parameters count unchanged.', $this->ldapTestId);
    }

    $this->ldapTestId = $this->module_name . ': cron test';
    $this->assertTrue(drupal_cron_run(), t('Cron can run with ldap user enabled.'), $this->ldapTestId);


    // test user token functions
    $this->ldapTestId = $this->module_name . ': user tokens';
    $entity = new stdClass();
    $entity->lname['und'][0]['value'] = 'doe';
    $entity->dept['und'][0]['value'] = 'physics';
    $entity->dept['und'][1]['value'] = 'chemistry';
    $account = new stdClass();
    $account->mail = 'jdoe@college.edu';
    $mail = ldap_user_token_replace('[property.mail]', $account, $entity);
    $this->assertTrue($mail == $account->mail, t('[property.mail] token worked on ldap_user_token_replace().'), $this->ldapTestId);
    $dept1 = ldap_user_token_replace('[field.dept:1]', $account, $entity);
    $this->assertTrue($dept1 == $entity->dept['und'][1]['value'], t('[field.dept:1] token worked on ldap_user_token_replace().'), $this->ldapTestId);
    $lname = ldap_user_token_replace('[field.lname]', $account, $entity);
    $this->assertTrue($lname ==  $entity->lname['und'][0]['value'], t('[field.lname] token worked on ldap_user_token_replace().'), $this->ldapTestId);

  
    $sids = array('activedirectory');
    $this->prepTestData($sids, 'provision0', 'default');


    $this->ldapTestId = $this->module_name . ': construct ldap_user_conf object';
    $ldap_user_conf = ldap_user_conf('admin', TRUE);
    $this->assertTrue(is_object($ldap_user_conf), t('ldap_conf class instanticated'), $this->ldapTestId);


    // test basic ldap user functions
    $synch_context = LDAP_USER_SYNCH_CONTEXT_AUTHENTICATE_DRUPAL_USER;

    $account = NULL;
    $user_edit = array('name' => 'jkeats');
    $this->ldapTestId = $this->module_name . ': provisionDrupalAccount function test';

    // test method provisionDrupalAccount() 
    $jkeats = $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
    
    $jkeats = user_load_by_name('jkeats');
    list($jkeats_account, $jkeats_user_entity) = ldap_user_load_user_acct_and_entity($jkeats->uid, 'uid');
  //  debug('initially provisioned user and entity'); debug($jkeats_account); debug($jkeats_user_entity);
 
 
 //   debugging check that field_lname is created and saveable
 //    $edit = array();
 //   $edit['field_lname']['und'][0]['value'] = 'barclay';
 //   $account = user_save($jkeats_account, $edit);
 //   list($jkeats_account, $jkeats_user_entity) = ldap_user_load_user_acct_and_entity($jkeats->uid, 'uid');
 //   debug('saved user and entity'); debug($jkeats_account); debug($jkeats_user_entity);
   
    
    $this->assertTrue(is_object($jkeats_account) && is_object($jkeats_user_entity), t('ldap_user_load_user_acct_and_entity() method tested'), $this->ldapTestId);

    $properties_set = (
      $jkeats->name == 'jkeats' &&
      $jkeats->mail == 'boygen@hotmail.com' &&
      $jkeats->init == 'boygen@hotmail.com' &&
      $jkeats->status == 1
    );
    $this->assertTrue($properties_set, t('user name, mail, init, and status correctly populated for jkeats'), $this->ldapTestId);

    $fields_set = (
      isset($jkeats->ldap_user_puid['und'][0]['value']) &&
      $jkeats->ldap_user_puid['und'][0]['value'] == 'e2eb4d760f81e89df1524cff71f720a0' &&
      isset($jkeats->ldap_user_puid_property['und'][0]['value']) &&
      $jkeats->ldap_user_puid_property['und'][0]['value'] == 'pixotechcomregistryuniqueid' &&
      isset($jkeats->ldap_user_puid_sid['und'][0]['value']) &&
      $jkeats->ldap_user_puid_sid['und'][0]['value'] == 'activedirectory' &&
      isset($jkeats->ldap_user_current_dn['und'][0]['value']) &&
      $jkeats->ldap_user_current_dn['und'][0]['value'] == 'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com'
    );
    $this->assertTrue($fields_set, t('user ldap_user_puid, ldap_user_puid_property, ldap_user_puid_sid, and  ldap_user_current_dn correctly populated for jkeats'), $this->ldapTestId);


    $data_diff = array_diff(
      $jkeats->data['ldap_authentication'],
      array (
      'init' =>
        array (
          'sid' => 'activedirectory',
          'dn' => NULL,
          'mail' => 'boygen@hotmail.com',
        ),
      )
     );
    $this->assertTrue(count($data_diff) == 0, t('user->data array correctly populated for jkeats'), $this->ldapTestId);
    // test account exists with correct username, mail, fname, puid, puidfield, dn

    // change some user mock ldap data first, (mail and fname) then synch
    $account = user_load_by_name('jkeats');
    $user_edit = NULL;
    $ldap_user_conf->ldapUserSynchMappings = array();
    $sid = 'activedirectory';
    $ldap_user_conf->ldapUserSynchMappings[LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER][$sid]['[property.mail]'] = array(
      'sid' => $sid,
      'ldap_attr' => '[mail]',
      'user_attr' => '[property.mail]',
      'convert' => 0,
      'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
      'contexts' => array(LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER),
      'name' => 'Property: Mail',
      'enabled' => TRUE,
      'config_module' => 'ldap_servers',
      'synch_module' => 'ldap_user',
      'user_tokens' => '',
      );
    $ldap_user_conf->save();
    
    $this->testFunctions->setFakeServerUserAttribute('activedirectory', 'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com', 'mail', 'boygen@yahoo.com', 0);
    //debug('call to synchToDrupalAccount'); debug(array($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, NULL, TRUE));
    $user = $ldap_user_conf->synchToDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_UPDATE_DRUPAL_USER, NULL, TRUE);
    //debug('user after synchToDrupalAccount'); debug($user);
    $jkeats = user_load_by_name('jkeats');
    $jkeats_uid = $jkeats->uid;
    $this->assertTrue($jkeats->mail == 'boygen@hotmail.com', t('synchToDrupalAccount worked for property (mail) for jkeats'), $this->ldapTestId);

   // return TRUE;
     // test account exists with correct username, mail, fname, puid, puidfield, dn
  //  debug('jkeats after user synchToDrupalAccount'); debug($jkeats);


    // delete and recreate test account to make sure account is in correct state
    $ldap_user_conf->deleteDrupalAccount('jkeats', LDAP_USER_SYNCH_CONTEXT_DELETE_DRUPAL_USER);
    $this->assertFalse(user_load($jkeats_uid, TRUE), t('deleteDrupalAccount deleted jkeats successfully'), $this->ldapTestId);
    
    $ldap_server = ldap_servers_get_servers('activedirectory', 'enabled', TRUE, TRUE);
    $ldap_server->refreshFakeData(); 
    $account = NULL;
    $user_edit = array('name' => 'jkeats');
    $jkeats = $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);

   // debug('new jkeats'); debug($jkeats);
   //debug('ldap_user_conf synchMapping and ldapUserSynchMappings'); debug($ldap_user_conf->synchMapping); debug($ldap_user_conf->ldapUserSynchMappings);
    /**
     * test that $ldap_user_conf->synchToDrupalAccount() works for various contexts.
     * make sure changing when a given field/property is flagged for a particular context, everything works
     * tests one property (property.mail) and one field (field.field_lname) as well as username, puid
     */
    
    $sid = 'activedirectory';
    $tests = array();
    
    $tests[] =  array(
      'disabled' => 0,
      'user' => 'jkeats',
      'field_name' => 'field_lname',
      // field_values are fake values to be set in fake ldap for test
      //   first values are what will be in ldap on account provision
      //   second values are what will be in ldap on account synch test
      'field_values' => array(array('keatsalicious'), array('keats-o-matic')),
      // field_results are desired resuls
      //   first value are desired results when synch disabled (generally first property_values result, but 'mail' etc may have exceptions)
      //   second value are desired results when synch enabled
      'field_results' => array('keatsalicious', 'keats-o-matic'),  // first value is what is desired on synch, second if no sycn
      'field_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => '[sn]',
        'user_attr' => '[field.field_lname]',
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'user_tokens' => '',
        'config_module' => 'ldap_user',
        'synch_module' => 'ldap_user',
        'enabled' => TRUE,
        'contexts' => array(),
        'name' => 'Field: Last Name',
      ),
    );

    $tests[] =  array(
      'disabled' => 0,
      'user' => 'jkeats',
      'property_name' => 'mail',
      // property_values are fake values to be set in fake ldap for test
      //   first values are what will be in ldap on account provision
      //   second values are what will be in ldap on account synch test
      'property_values' => array(array('jkeats@hotmail.com'), array('jkeats@yahoo.com')),
      // property_results are desired results
      //   first value are desired results when synch disabled (generally first property_values result, but 'mail' etc may have exceptions)
      //   second value are desired results when synch enabled
      'property_results' => array('jkeats@hotmail.com', 'jkeats@yahoo.com'),
      'property_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => '[mail]',
        'user_attr' => '[property.mail]',
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'contexts' => array(),
        'name' => 'Property: Mail',
        'enabled' => TRUE,
        'config_module' => 'ldap_servers',
        'synch_module' => 'ldap_user',
        'user_tokens' => '',
      ),
    );
 
    // test for constants in use (e.g. "Smith" and "0") instead of tokens e.g. "[sn]" and "[enabled]"
    $tests[] =  array(
      'disabled' => 0,
      'user' => 'jkeats',
      'field_name' => 'field_lname',
      'field_values' => array(array('keatsalicious'), array('keats-o-matic')),
      'field_results' => array('Smith', 'Smith'),
      'field_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => 'Smith', // testing of a constant mapped to a field.  that is everyone should have last name smith
        'user_attr' => '[field.field_lname]',
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'contexts' => array(),
        'name' => 'Field: Last Name',
        'enabled' => TRUE,
        'config_module' => 'ldap_user',
        'synch_module' => 'ldap_user',
        'user_tokens' => '',
      ),
    );
    
    $tests[] =  array(
      'disabled' => 0,
      'user' => 'jkeats',
      'property_name' => 'status',
      'property_values' => array(array('z'), array('z')),
      'property_results' => array(0, 0),
      'property_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => '0',
        'user_attr' => '[property.status]',  // testing of a constant mapped to property
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'contexts' => array(),
        'name' => 'Property: Status',
        'enabled' => TRUE,
        'config_module' => 'ldap_servers',
        'synch_module' => 'ldap_user',
        'user_tokens' => '',
      ),
    );
    

    // test for compound tokens

    $tests[] =  array(
      'disabled' => 1,
      'user' => 'jkeats',
      'field_name' => 'field_display_name',
      // field_values are fake values to be set in fake ldap for test
      //   first values are what will be in ldap on account provision
      //   second values are what will be in ldap on account synch test
      'field_values' => array(array('John', 'Doe'), array('John', 'Keats')),
      // property_results are desired results
      //   first value are desired results when synch disabled (generally first property_values result, but 'mail' etc may have exceptions)
      //   second value are desired results when synch enabled
      'field_results' => array('John Doe', 'John Keats'),  // desired results
      'field_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => '[givenname] [sn]',
        'user_attr' => '[field.field_display_name]',
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'contexts' => array(),
        'name' => 'Field: Display Name',
        'enabled' => TRUE,
        'config_module' => 'ldap_user',
        'synch_module' => 'ldap_user',
        'user_tokens' => '',
      ),
    );
    
    // test for compound tokens
    $tests[] =  array(
      'disabled' => 0,
      'user' => 'jkeats',
      'property_name' => 'signature',
      // property_values are fake values to be set in fake ldap for test
      //   first values are what will be in ldap on account provision
      //   second values are what will be in ldap on account synch test
      'property_values' => array(array('jkeats'), array('jkeats2')),
      // property_results are desired results
      //   first value are desired results when synch disabled (generally first property_values result, but 'mail' etc may have exceptions)
      //   second value are desired results when synch enabled
      'property_results' => array('jkeats@mycompany.com', 'jkeats2@mycompany.com'),
      'property_mapping' => array(
        'sid' => $sid,
        'ldap_attr' => '[cn]@mycompany.com',
        'user_attr' => '[property.signature]',
        'convert' => 0,
        'direction' => LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER,
        'contexts' => array(),
        'name' => 'Property: Signature',
        'enabled' => TRUE,
        'config_module' => 'ldap_servers',
        'synch_module' => 'ldap_user',
        'user_tokens' => '',
      ),
    );
    
    // @todo test with compound token string
    // @todo test with binary field
    
    $test_contexts = ldap_user_synch_contexts();
   // $test_contexts = array(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);
    
    /** Tests for various synch contexts **/
    foreach ($tests as $j => $test) {
      if ($test['disabled']) {
        continue;
      }
      $field_name = isset($test['field_name']) ? $test['field_name'] : FALSE;
      $property_name = isset($test['property_name']) ? $test['property_name'] : FALSE;
      $direction = ($property_name) ? $test['property_mapping']['direction'] : $test['field_mapping']['direction'];
      foreach ($test_contexts  as $i => $synch_context) {  // test for each context
        foreach (array(0, 1) as $flagged_for_synch) { // @todo add 0 back into arraytest with and without field flagged for synch to test for false positives
         // debug("test context: $context, flagged for synch:" . (int)$flagged_for_synch);

          
          // 1. set fake ldap values for field and property in fake ldap server
          // and clear out mappings and set to provision account with test field and prop[0] on provision
          $ldap_server = ldap_servers_get_servers('activedirectory', 'enabled', TRUE);
          $this->prepTestData($sids, 'provision0', 'default'); // make sure data back to original state
          if ($property_name) {
            $token_attributes = array();
            ldap_servers_token_extract_attributes($token_attributes,  $test['property_mapping']['ldap_attr']);
            foreach ($token_attributes as $k => $attr_name) {
              $this->testFunctions->setFakeServerUserAttribute(
                'activedirectory',
                'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com',
                $attr_name,
                $test['property_values'][0][$k],
                0);
            }
            $property_token = '[property.' . $property_name . ']';
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$property_token] = $test['property_mapping'];
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$property_token]['contexts'] = array(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);

          }
          if ($field_name) {
            $token_attributes = array();
            ldap_servers_token_extract_attributes($token_attributes,  $test['field_mapping']['ldap_attr']);
            //debug('token_attributes'); debug($token_attributes);
            foreach ($token_attributes as $k => $attr_name) {
              $this->testFunctions->setFakeServerUserAttribute(
                'activedirectory',
                'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com',
                $attr_name,
                $test['field_values'][0][$k],
                0);
            }
            $field_token = '[field.'    . $field_name . ']';
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token] = $test['field_mapping'];
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['contexts'] = array(LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER);
          }
          
          $ldap_user_conf->save();
          $ldap_user_conf = ldap_user_conf('admin', TRUE);
          //debug('ldap_user_conf in prep'); debug($ldap_user_conf->synchMappings); debug($ldap_user_conf->ldapUserSynchMappings);
          ldap_servers_flush_server_cache();
          
          // 2. delete user
          $username = $test['user'];
          $user_object = user_load_by_name($username);
          if (is_object($user_object)) {
            user_delete($user_object->uid); // watch out for this.  
          }
          
          // 3. create new user with provisionDrupalAccount
          $account = NULL;
          $user_edit = array('name' => $username);
         // $this->ldapTestId = $this->module_name . ': provisionDrupalAccount function test';
          $result = $ldap_user_conf->provisionDrupalAccount($account, $user_edit, LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER, NULL, TRUE);
          //debug("ldap user test line 420: provisionDrupalAccount result"); debug($result);
          $this->ldapTestId = $this->module_name . ":provisionDrupalAccount.i=$j.contextenabled=$flagged_for_synch.context=" . ldap_user_synch_context_text($synch_context);
          list($user_object, $user_entity) = ldap_user_load_user_acct_and_entity($username);
         // debug('initially provisioned user and entity for:'. $username); debug($user_object); debug($user_entity);
        //  debug('before user synch,  mail (should be jkeats@hotmail.com)=' . $user_object->{$property_name} . ',lname (should be keatsalicious) =') . debug($user_entity->{$field_name});        
          
          if ($property_name) {
            $property_success = ($user_object->{$property_name} == $test['property_results'][0]);
            $this->assertTrue($property_success, t("provisionDrupalAccount worked for property $property_name"), $this->ldapTestId);
          }
          if ($field_name) {
            $field_success = isset($user_entity->{$field_name}['und'][0]['value']) &&
              $user_entity->{$field_name}['und'][0]['value'] == $test['field_results'][0];          
            $this->assertTrue($field_success,    t("provisionDrupalAccount worked for field $field_name"),       $this->ldapTestId);
            if (!$field_success) {
              //debug('field fail,'. $field_name); debug($user_entity);
              
            }
          //  debug("initially provisioned user and entity, where desired value of $field_name = ". $test['field_results'][0]
         //     . 'failed. value found=' . $user_entity->{$field_name}['und'][0]['value']);
          //  debug($user_object); debug($user_entity);
                  
           
          }
          continue;
         // continue; //skip latter tests @todo remove
          
          // 5. set mappings to be tested for field and property being tested
        //  debug("property_name=$property_name");
          if ($property_name) {
            $property_token = '[property.' . $property_name . ']';
            unset($ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$property_token]);
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$property_token] = $test['property_mapping'];
            if ($flagged_for_synch) {
              $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$property_token]['contexts'] = array($synch_context);
            }
          }
          
       //   debug("field_name=$field_name");
          if ($field_name) {
            $field_token = '[field.'    . $field_name . ']';
            unset($ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_name]);
            $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_name] = $test['field_mapping'];
            if ($flagged_for_synch) {
              $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_name]['contexts'] = array($synch_context);
            }
          }
         
          $ldap_user_conf->save();
          $ldap_user_conf = ldap_user_conf('admin', TRUE);
         // debug('-------2'); debug($ldap_user_conf->ldapUserSynchMappings);
  
          // 6. change fake ldap values for field and property, to property[1] and field[1]  
          if ($property_name) {
            $token_attributes = array();
            ldap_servers_token_extract_attributes($token_attributes,  $test['property_mapping']['ldap_attr']);
            foreach ($token_attributes as $k => $attr_name) {
              $this->testFunctions->setFakeServerUserAttribute(
                'activedirectory',
                'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com',
                $attr_name,
                $test['property_values'][1][$k],
                0);
            }
          }
          if ($field_name) {
            $token_attributes = array();
            ldap_servers_token_extract_attributes($token_attributes,  $test['field_mapping']['ldap_attr']);
            foreach ($token_attributes as $k => $attr_name) {
              $this->testFunctions->setFakeServerUserAttribute(
                'activedirectory',
                'CN=jkeats,CN=Users,DC=activedirectory,DC=ldap,DC=pixotech,DC=com',
                 $attr_name,
                $test['field_values'][1][$k],
                0);
            }
          }
          ldap_servers_flush_server_cache();
          
          // 8. debug statements
          list($user_object, $user_entity) = ldap_user_load_user_acct_and_entity($username);
          //debug('initially provisioned user and entity'); debug($user_object); debug($user_entity);
         // debug('before user synch, mail=' . $user_object->mail . ',lname=') . debug($user_entity->field_lname);
          
          // 8. execute synch
          $user_edit = array();
          $ldap_user_conf->synchToDrupalAccount($user_object, $user_edit, $synch_context, NULL, TRUE);
  

          list($user_object, $user_entity) = ldap_user_load_user_acct_and_entity($username); 
          //debug('after user synch, mail=' . $jkeats->mail . ',lname=') . debug($user_entity->field_lname);
          if ($property_name) {
            $property_desired_value = $flagged_for_synch; // field[0] or field[1]
            if ($property_name == 'mail' && $synch_context == LDAP_USER_SYNCH_CONTEXT_INSERT_DRUPAL_USER && $flagged_for_synch == 0) {
              $property_desired_value = 1;
              // on insert email is always derived regardless of ldap_user module config
            }

            $this->ldapTestId = $this->module_name . ":synchToDrupalAccount.property=$property_name.i=$j.contextenabled=$flagged_for_synch.context=" . ldap_user_synch_context_text($synch_context);
            $property_success = ($user_object->{$property_name} == $test['property_results'][$property_desired_value]);
            $this->assertTrue($property_success, t("synchToDrupalAccount worked for property ($property_name) for " . $username), $this->ldapTestId);
            if (!$property_success) {
              debug("property synch failed: actual value " . $user_object->{$property_name} .'!= desired value:' . $test['property_results'][$property_desired_value]);
              debug($user_object);
            }

          }
          
          if ($field_name) {
            $field_desired_value = $flagged_for_synch; // field[0] or field[1]
            $this->ldapTestId = $this->module_name . ":synchToDrupalAccount.field=$field_name.i=$j.contextenabled=$flagged_for_synch.context=" . ldap_user_synch_context_text($synch_context);
            $field_success = isset($user_entity->{$field_name}['und'][0]['value']) &&
                $user_entity->{$field_name}['und'][0]['value'] == $test['field_results'][$field_desired_value];
            $this->assertTrue($field_success, t("synchToDrupalAccount worked for field ($field_name) for " . $username), $this->ldapTestId);
            if (!$field_success) {
              debug("field synch succes=$field_success: actual value:" . $user_entity->{$field_name}['und'][0]['value'] .'!= set value:' . $test['field_results'][$field_desired_value]);
              debug($user_entity);
            }
          }
        }
      }
    }
  }
}

class LdapUserLdapProvisionTests extends LdapUserTestCasev2 {

  public static function getInfo() {
    return array(
      'name' => 'LDAP User Tests: Provision to LDAP',
      'description' => 'Test provisioning of ldap entries in ldap.',
      'group' => 'LDAP User'
    );
  }
  
 /**
   * make sure install succeeds and ldap user functions/methods work
   */
  function testProvisionToLdapFunctions() {

    $this->ldapTestId = $this->module_name . ': setup success';

    // just to give warning if setup doesn't succeed.  may want to take these out at some point.
    $setup_success = (
        module_exists('ldap_user') &&
        module_exists('ldap_servers') &&
        (variable_get('ldap_simpletest', 0) > 0)
      );
    $this->assertTrue($setup_success, ' ldap_user setup successful', $this->ldapTestId);

    $this->ldapTestId = $this->module_name . ': test for provision to ldap on drupal acct create';
  
    $sids = array('activedirectory');
    $this->prepTestData($sids, 'provision1'); // this will create the proper ldap_user configuration from ldap_test/ldap_user.conf.inc
    
    $ldap_user_conf = ldap_user_conf('default', TRUE);
    //debug($ldap_user_conf);
    
    
    // 9.B. Create and approve new user, populating first and last name.
    $username = 'johnx95b';
    $user_edit = array(
      'name' => $username,
      'mail' => $username . '@example.com',
      'pass' => user_password(),
      'status' => 1,
    );
    $user_acct = new stdClass();
    $user_acct->is_new = TRUE;
    $user_acct->field_fname['und'][0]['value'] = 'John';
    $user_acct->field_lname['und'][0]['value'] = 'Doe';
    
    $drupal_account = user_save($user_acct, $user_edit);
    
  //  debug('drupal_account'); debug($drupal_account);
    
    $servers = ldap_servers_get_servers(NULL, NULL, FALSE, TRUE);
    $desired_dn = "cn=$username,ou=people,dc=activedirectory,dc=ldap,dc=pixotech,dc=com";
   // debug("dn=$desired_dn in activedirectory server"); debug($servers['activedirectory']->entries[$desired_dn]);
    $ldap_entry_success = (
      isset($servers['activedirectory']->entries[$desired_dn]) &&
      $servers['activedirectory']->entries[$desired_dn]['dn'] == $desired_dn &&
      $servers['activedirectory']->entries[$desired_dn]['cn'][0] == $username &&
      $servers['activedirectory']->entries[$desired_dn]['displayName'][0] == 'John Doe' &&
      $servers['activedirectory']->entries[$desired_dn]['guid'][0] == 'ldap.pixotech.com.uid.2' &&
      $servers['activedirectory']->entries[$desired_dn]['provisionSource'][0] == 'drupal.pixotech.com'
    );
    
    $this->assertTrue($ldap_entry_success, t("provision of ldap entry on user create succeeded for " . $username), $this->ldapTestId);
    //confirm that ldap entry exists with proper attributes
        
    //  Change lastname and first name (in drupal) and save user (to test ldapSynch event handler)
    // confirm that appropriate attributes were changed in ldap entry
    $user_acct = user_load_by_name('johnx95b');
    $edit = array();
    $edit['field_fname']['und'][0]['value'] = 'Johnny';
    $edit['field_lname']['und'][0]['value'] = 'Rotten';     
    $user_acct = user_save($user_acct, $edit);
    $user_acct = user_load_by_name('johnx95b');
    
    $servers = ldap_servers_get_servers(NULL, NULL, FALSE, TRUE);
 //   debug('user entry save'); debug($user_acct);
    
    $entry = $servers['activedirectory']->entries[$desired_dn];
   // debug('servers entry'); debug($entry);
   
    $ldap_entry_success = (
      isset($servers['activedirectory']->entries[$desired_dn])
      && $entry['givenName'][0] == 'Johnny'
      && $entry['displayName'][0] == 'Johnny Rotten' 
      && $entry['sn'][0] == 'Rotten' 
    );
    // && $servers['activedirectory']->entries[$desired_dn]['displayName'][0] == 'Johnny Rotten' 
       //   && $servers['activedirectory']->entries[$desired_dn]['sn'][0] == 'Rotten' 
     // 
      
    $this->assertTrue($ldap_entry_success, t("provision of ldap entry on user create succeeded for " . $username), $this->ldapTestId);
        
    //Delete user in drupal.
    user_delete($user_acct->uid);
    ldap_servers_flush_server_cache();
   // $server = ldap_servers_get_servers('activedirectory', NULL, TRUE, TRUE);
    $entry = $servers['activedirectory']->entries[$desired_dn];
    //debug('entry after delete'); debug($entry);
    // confirm that ldap entry for user is removed.
    
    
    // do a password reset of some sort
    // try to add a drupal user that conflicts with an ldap user
    // try a binary fields such as a user profile image
    
    
  }

}

class LdapUserUITests extends LdapUserTestCasev2 {

  public static function getInfo() {
    return array(
      'name' => 'LDAP User Tests: User Interface v2',
      'description' => 'Test ldap user admin interface.',
      'group' => 'LDAP User'
    );
  }

  /**
   * make sure user admin interface works.  (its a beast)
   */
  function testUI() {

    $this->ldapTestId = $this->module_name . ': user interface tests';

    // just to give warning if setup doesn't succeed.  may want to take these out at some point.
    $setup_success = (
        module_exists('ldap_user') &&
        module_exists('ldap_servers') &&
        (variable_get('ldap_simpletest', 0) > 0)
      );
    $this->assertTrue($setup_success, ' ldap_user setup successful', $this->ldapTestId);

    $sids = array('activedirectory');
    $this->prepTestData($sids, 'provision0', 'default');


    $this->privileged_user = $this->drupalCreateUser(array(
      'administer site configuration',
      ));
    $this->drupalLogin($this->privileged_user);

    $ldap_user_conf = ldap_user_conf();
  //  debug('ldap_user_conf before form submission'); debug($ldap_user_conf);


    $this->drupalGet('admin/config/people/ldap/user');

    // Populate the field settings with new settings.
    $sid = 'activedirectory';
    $wsKey = 'sdafjlksjadsdafjkksdafjsdfsdjfsdf';
    $wsUserIps = array('1.2.3.4');
    $edit = array(
      'drupalAcctProvisionServer' => $sid,
      'drupalAcctProvisionEvents[' . LDAP_USER_CONFLICT_LOG . ']' => 1,
      'drupalAcctProvisionEvents[' . LDAP_USER_CONFLICT_RESOLVE . ']' => 1,
      'drupalAcctProvisionEvents[' . LDAP_USER_CONFLICT_RESOLVE_DEFAULT . ']' => 1,
      'userConflictResolve' => LDAP_USER_CONFLICT_LOG,
      'acctCreation' => LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR_DEFAULT,
      'wsEnabled'  => 1,
      'wsActions[create]' => 1,
      'wsActions[synch]' => 1,
      'wsActions[disable]' => 1,
      'wsActions[delete]' => 1,
      'wsUserIps' => join("\n", $wsUserIps),
      'wsKey' => $wsKey,

      '1__activedirectory__sm__ldap_attr__7' => 'sn',
      '1__activedirectory__sm__convert__7' => FALSE,
      '1__activedirectory__sm__direction__7' => 1,
      '1__activedirectory__sm__user_attr__7' => 'field.field_lname',
      '1__activedirectory__sm__1__7' => TRUE,
      '1__activedirectory__sm__2__7' => TRUE,
      '1__activedirectory__sm__3__7' => TRUE,
      '1__activedirectory__sm__4__7' => TRUE,

      '1__activedirectory__sm__ldap_attr__8' => 'givenname',
      '1__activedirectory__sm__convert__8' => FALSE,
      '1__activedirectory__sm__direction__8' => 1,
      '1__activedirectory__sm__user_attr__8' => 'field.field_fname',
      '1__activedirectory__sm__1__8' => TRUE,
      '1__activedirectory__sm__2__8' => TRUE,
      '1__activedirectory__sm__3__8' => TRUE,
      '1__activedirectory__sm__4__8' => TRUE,

    );

    $this->drupalPost('admin/config/people/ldap/user', $edit, t('Save'));
    
    $direction = LDAP_USER_SYNCH_DIRECTION_TO_DRUPAL_USER;
    $ldap_user_conf = ldap_user_conf('admin', TRUE);
   // debug('user conf object after save'); debug($ldap_user_conf);
  //  debug('ldap_user_conf variable'); debug(variable_get('ldap_user_conf',''));
    $this->assertTrue($ldap_user_conf->drupalAcctProvisionServer == 'activedirectory', t('Server field set correctly'), $this->ldapTestId);
    $this->assertTrue(
      isset($ldap_user_conf->drupalAcctProvisionEvents[LDAP_USER_DRUPAL_USER_CREATE_ON_LOGON]) &&
      isset($ldap_user_conf->drupalAcctProvisionEvents[LDAP_USER_DRUPAL_USER_CREATE_ON_MANUAL_ACCT_CREATE]) &&
      isset($ldap_user_conf->drupalAcctProvisionEvents[LDAP_USER_DRUPAL_USER_CREATE_ON_ALL_USER_CREATION])
      , t('provision methods field set correctly'), $this->ldapTestId);
    $this->assertTrue($ldap_user_conf->userConflictResolve == LDAP_USER_CONFLICT_LOG, t('Account conflict field set correctly'), $this->ldapTestId);
    $this->assertTrue($ldap_user_conf->acctCreation == LDAP_USER_ACCT_CREATION_LDAP_BEHAVIOR_DEFAULT, t('Account creation field set correctly'), $this->ldapTestId);
    
    $field_token = '[field.field_lname]';
    $field_lname_set_correctly = ($ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['enabled'] == TRUE &&
      $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['direction'] == 1 &&
      $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['ldap_attr'] == '[sn]');

    $this->assertTrue($field_lname_set_correctly, t('Synch mapping for field.field_lname  field set correctly'), $this->ldapTestId);
    if (!$field_lname_set_correctly) {
      debug('ldap_user_conf->synchMapping[direction][sid][field.field_lname]'); debug($ldap_user_conf->ldapUserSynchMappings[$direction][$sid]['field.field_lname']);
    }
    
    $field_token = '[field.field_fname]';
    $field_fname_set_correctly = ($ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['enabled'] == TRUE &&
      $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['direction'] == 1 &&
      $ldap_user_conf->ldapUserSynchMappings[$direction][$sid][$field_token]['ldap_attr'] == '[givenname]');

    $this->assertTrue($field_fname_set_correctly, t('Synch mapping for field.field_lname  field set correctly'), $this->ldapTestId);
     if (!$field_fname_set_correctly) {
      debug('ldap_user_conf->synchMapping[direction][sid][field.field_lname]'); debug($ldap_user_conf->ldapUserSynchMappings[$direction][$sid]['field.field_lname']);
    }

    $this->assertTrue($ldap_user_conf->wsKey == $wsKey, t('wsKey field set correctly'), $this->ldapTestId);
    $this->assertTrue($ldap_user_conf->wsEnabled == 1, t('wsEnabled field set correctly'), $this->ldapTestId);
    $this->assertTrue($ldap_user_conf->wsUserIps[0] == $wsUserIps[0], t('wsUserIps field set correctly'), $this->ldapTestId);
    if (!($ldap_user_conf->wsUserIps[0] == $wsUserIps[0])) {
      debug('wsUserIps'); debug($ldap_user_conf->wsUserIps); debug($wsUserIps[0]);
    }

    $this->assertTrue(
      in_array('create',$ldap_user_conf->wsActions) &&
      in_array('synch',$ldap_user_conf->wsActions) &&
      in_array('disable',$ldap_user_conf->wsActions) &&
      in_array('delete',$ldap_user_conf->wsActions)
      , t('wsActions fields set correctly'), $this->ldapTestId);

  }

}

class LdapUserFunctionalTests extends LdapUserTestCasev2 {
  public static function getInfo() {
    return array(
      'name' => 'LDAP User Tests: Basic Functional Tests v2',
      'description' => 'Test ldap user.  Event handling functions such as logon, user update, etc.',
      'group' => 'LDAP User'
    );
  }

/**
 * test variations on drupal user account creation/provisioning and updating
 * these are not api calls, they are actual user create, user edit, user logon etc
 * events being tested.  api calls are tested in testFunctionsAndInstall()
 */
function x_testDrupalUserProvision() {

  $this->ldapTestId = 'UserProvision';
  $this->serversData = 'activedirectory.ldif';
 // $this->prepTestData();


  // create user with user_save with no ldap data specified and make sure its derived

  // create user with user_save with all ldap data specified and make sure it overrides defaults

  // test for provisioning of confict in puid and correct errors thrown

  // test for provisioning with conflict username

  // test for provisioning with conflict in ldap, but not drupal users or puid

  // test webservices for provisioning



}


/**
 * test variations on ldap entry account creation/provisioning and updating
 * these are not api calls, they are actual drupal user create, user edit, user logon etc
 * event handlers being tested.  api calls are tested in testFunctionsAndInstall()
 */
function x_testLdapUserProvision() {

  $this->ldapTestId = 'LdapeEntryProvision';
  $this->serversData = 'activedirectory.ldif';
 // $this->prepTestData();


  // create user with user_save with no ldap data specified and make sure its derived

  // create user with user_save with all ldap data specified and make sure it overrides defaults

  // test for provisioning of confict in puid and correct errors thrown

  // test for provisioning with conflict username

  // test for provisioning with conflict in ldap, but not drupal users or puid

  // test webservices for provisioning



}

}
